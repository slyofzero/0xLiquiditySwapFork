"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [5275], {
        74187: function(e, t, n) {
            let a, r, i, f, s, o, c, d, l, u, m, p;
            n.d(t, {
                B: function() {
                    return r4
                },
                E: function() {
                    return fg
                },
                G: function() {
                    return iI
                },
                H: function() {
                    return iL
                },
                J: function() {
                    return ru
                },
                K: function() {
                    return rm
                },
                L: function() {
                    return rQ
                },
                M: function() {
                    return fy
                },
                N: function() {
                    return fk
                },
                P: function() {
                    return fC
                },
                T: function() {
                    return fF
                },
                V: function() {
                    return fT
                },
                W: function() {
                    return r0
                },
                Y: function() {
                    return is
                },
                Z: function() {
                    return io
                },
                _: function() {
                    return ic
                },
                a: function() {
                    return fh
                },
                a$: function() {
                    return rN
                },
                a0: function() {
                    return na
                },
                a4: function() {
                    return rs
                },
                a5: function() {
                    return r_
                },
                a6: function() {
                    return ro
                },
                a8: function() {
                    return nq
                },
                aA: function() {
                    return rT
                },
                aB: function() {
                    return rP
                },
                aD: function() {
                    return rO
                },
                aE: function() {
                    return rD
                },
                aF: function() {
                    return rK
                },
                aG: function() {
                    return rZ
                },
                aI: function() {
                    return rG
                },
                aJ: function() {
                    return rH
                },
                aK: function() {
                    return rS
                },
                aL: function() {
                    return nl
                },
                aM: function() {
                    return nu
                },
                aN: function() {
                    return no
                },
                aP: function() {
                    return tu
                },
                aQ: function() {
                    return im
                },
                aS: function() {
                    return iz
                },
                aT: function() {
                    return iF
                },
                aU: function() {
                    return e2
                },
                aV: function() {
                    return n5
                },
                aW: function() {
                    return r$
                },
                aX: function() {
                    return nd
                },
                aZ: function() {
                    return rI
                },
                a_: function() {
                    return rL
                },
                aa: function() {
                    return nX
                },
                ac: function() {
                    return ni
                },
                ad: function() {
                    return nf
                },
                ae: function() {
                    return nn
                },
                af: function() {
                    return rc
                },
                al: function() {
                    return iB
                },
                am: function() {
                    return iR
                },
                an: function() {
                    return n3
                },
                ao: function() {
                    return iD
                },
                aq: function() {
                    return tx
                },
                as: function() {
                    return r9
                },
                av: function() {
                    return rC
                },
                aw: function() {
                    return rv
                },
                ax: function() {
                    return rz
                },
                ay: function() {
                    return rF
                },
                az: function() {
                    return rx
                },
                b: function() {
                    return fw
                },
                b0: function() {
                    return rM
                },
                b1: function() {
                    return ix
                },
                b2: function() {
                    return tn
                },
                b5: function() {
                    return ta
                },
                b7: function() {
                    return tf
                },
                b9: function() {
                    return tT
                },
                bA: function() {
                    return t4
                },
                bB: function() {
                    return t9
                },
                bF: function() {
                    return tB
                },
                bH: function() {
                    return tO
                },
                bI: function() {
                    return tD
                },
                bJ: function() {
                    return t$
                },
                bK: function() {
                    return tI
                },
                bL: function() {
                    return tL
                },
                bO: function() {
                    return t_
                },
                bP: function() {
                    return tj
                },
                bQ: function() {
                    return tU
                },
                bV: function() {
                    return iV
                },
                bZ: function() {
                    return i_
                },
                ba: function() {
                    return tS
                },
                bc: function() {
                    return td
                },
                bd: function() {
                    return tl
                },
                bk: function() {
                    return tH
                },
                bn: function() {
                    return tJ
                },
                bx: function() {
                    return t8
                },
                c: function() {
                    return fE
                },
                c$: function() {
                    return aw
                },
                c1: function() {
                    return iK
                },
                c5: function() {
                    return iQ
                },
                c9: function() {
                    return i2
                },
                cA: function() {
                    return ty
                },
                cB: function() {
                    return tb
                },
                cC: function() {
                    return tk
                },
                cD: function() {
                    return tC
                },
                cE: function() {
                    return th
                },
                cF: function() {
                    return tw
                },
                cG: function() {
                    return at
                },
                cH: function() {
                    return n9
                },
                cI: function() {
                    return aa
                },
                cJ: function() {
                    return ar
                },
                cK: function() {
                    return an
                },
                cL: function() {
                    return af
                },
                cM: function() {
                    return as
                },
                cN: function() {
                    return al
                },
                cO: function() {
                    return ab
                },
                cP: function() {
                    return ap
                },
                cQ: function() {
                    return ag
                },
                cR: function() {
                    return ao
                },
                cS: function() {
                    return az
                },
                cT: function() {
                    return aF
                },
                cU: function() {
                    return ah
                },
                cV: function() {
                    return ay
                },
                cW: function() {
                    return av
                },
                cX: function() {
                    return ak
                },
                cY: function() {
                    return aA
                },
                cZ: function() {
                    return aC
                },
                c_: function() {
                    return ac
                },
                cd: function() {
                    return fe
                },
                ch: function() {
                    return fa
                },
                cl: function() {
                    return i4
                },
                cr: function() {
                    return fo
                },
                ct: function() {
                    return iS
                },
                cu: function() {
                    return iP
                },
                cv: function() {
                    return rd
                },
                cw: function() {
                    return rE
                },
                cx: function() {
                    return rW
                },
                cy: function() {
                    return e5
                },
                cz: function() {
                    return tA
                },
                d: function() {
                    return fA
                },
                d0: function() {
                    return ax
                },
                d1: function() {
                    return aY
                },
                d2: function() {
                    return aX
                },
                d3: function() {
                    return aq
                },
                d4: function() {
                    return aV
                },
                d5: function() {
                    return aQ
                },
                d6: function() {
                    return aK
                },
                d7: function() {
                    return n8
                },
                d8: function() {
                    return aO
                },
                d9: function() {
                    return aP
                },
                dA: function() {
                    return a3
                },
                dB: function() {
                    return rj
                },
                dC: function() {
                    return tg
                },
                dD: function() {
                    return fd
                },
                dE: function() {
                    return fl
                },
                dF: function() {
                    return fp
                },
                dG: function() {
                    return iq
                },
                dH: function() {
                    return a1
                },
                dI: function() {
                    return fu
                },
                dJ: function() {
                    return fc
                },
                dK: function() {
                    return fm
                },
                dL: function() {
                    return iW
                },
                da: function() {
                    return aL
                },
                db: function() {
                    return nm
                },
                dc: function() {
                    return aT
                },
                dd: function() {
                    return a_
                },
                de: function() {
                    return a$
                },
                df: function() {
                    return aD
                },
                dg: function() {
                    return aN
                },
                dh: function() {
                    return aM
                },
                di: function() {
                    return aW
                },
                dj: function() {
                    return aU
                },
                dk: function() {
                    return a7
                },
                dl: function() {
                    return re
                },
                dm: function() {
                    return a4
                },
                dn: function() {
                    return a5
                },
                dp: function() {
                    return rt
                },
                dq: function() {
                    return rn
                },
                dr: function() {
                    return ra
                },
                ds: function() {
                    return aZ
                },
                dt: function() {
                    return ik
                },
                du: function() {
                    return ii
                },
                dv: function() {
                    return r7
                },
                dw: function() {
                    return ie
                },
                dx: function() {
                    return it
                },
                dy: function() {
                    return a2
                },
                dz: function() {
                    return a8
                },
                e: function() {
                    return fv
                },
                f: function() {
                    return fz
                },
                g: function() {
                    return fx
                },
                h: function() {
                    return fP
                },
                i: function() {
                    return fB
                },
                j: function() {
                    return fD
                },
                k: function() {
                    return f$
                },
                n: function() {
                    return rJ
                },
                o: function() {
                    return rq
                },
                s: function() {
                    return rY
                },
                t: function() {
                    return rX
                },
                w: function() {
                    return r1
                },
                x: function() {
                    return r6
                },
                y: function() {
                    return r5
                },
                z: function() {
                    return r2
                }
            });
            var b, g, h = n(61127),
                y = n(17213),
                w = n(39318),
                E = n(13010),
                k = n(99227),
                A = n(86816),
                C = n(18994),
                v = n(92598),
                z = n(5572),
                F = n(28410),
                x = n(58337),
                T = n(57273),
                S = n(14184),
                P = n(12060),
                B = n(36339),
                R = n(47293),
                O = n(55725),
                D = n(77273),
                $ = n(73760),
                I = n(31822),
                L = n(53690),
                N = n(74578),
                M = n(16211),
                _ = n(17567);
            n(61975);
            var j = n(22130),
                U = n(56662),
                W = n.n(U),
                G = n(68870),
                H = n.n(G),
                V = n(83230),
                K = n(58478),
                Z = n(90863),
                J = n(4129),
                q = n(56335),
                Y = n(54497),
                X = n(38649),
                Q = n(4470),
                ee = n(10205),
                et = n(57101),
                en = n(61053),
                ea = n(62281),
                er = n(29691),
                ei = n(28329),
                ef = n(99818),
                es = n(32557),
                eo = n(18125),
                ec = n(62984),
                ed = n(41730),
                el = n(50021),
                eu = n(93938),
                em = n(1377),
                ep = n(63393),
                eb = n(29293),
                eg = n(81570),
                eh = n(56535),
                ey = n(78694),
                ew = n(2093),
                eE = n(19115),
                ek = n(88049),
                eA = n(1728),
                eC = n(17845),
                ev = n(39046),
                ez = n(60805),
                eF = n(18128),
                ex = n(10506),
                eT = n(31617),
                eS = n(38925),
                eP = n(56011),
                eB = n(46929),
                eR = n(5053),
                eO = n(73496),
                eD = n(23194),
                e$ = n(9748),
                eI = n(96409),
                eL = n(97463),
                eN = n(60027),
                eM = n(75581),
                e_ = n(24857),
                ej = n(65313),
                eU = n(44662),
                eW = n(77438),
                eG = n(91671),
                eH = n(46083),
                eV = n(68133),
                eK = n(98730),
                eZ = n(15560),
                eJ = n(92063),
                eq = n(26644),
                eY = n(5246),
                eX = n(97258),
                eQ = n(6691),
                e0 = n(11953),
                e1 = n(25566),
                e6 = n(67133).Buffer;

            function e5(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                return void 0 !== e1 && e1.env[e] ? e1.env[e] : t
            }

            function e2() {
                return e5("contractPublisherAddress", "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808")
            }

            function e8(e) {
                return !!(e && e._isSigner)
            }

            function e3(e) {
                return !!(e && e._isProvider)
            }
            let e4 = {
                timeLimitMs: 50,
                sizeLimit: 250
            };
            class e9 extends h.c {
                constructor(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e4;
                    super(e, t), this._timeLimitMs = n.timeLimitMs || 250, this._sizeLimit = n.sizeLimit || 50, this._pendingBatchAggregator = null, this._pendingBatch = null
                }
                sendCurrentBatch(e) {
                    this._pendingBatchAggregator && clearTimeout(this._pendingBatchAggregator);
                    let t = this._pendingBatch || [];
                    this._pendingBatch = null, this._pendingBatchAggregator = null;
                    let n = t.map(e => e.request);
                    return this.emit("debug", {
                        action: "requestBatch",
                        request: y.deepCopy(e),
                        provider: this
                    }), w.fetchJson(this.connection, JSON.stringify(n)).then(e => {
                        this.emit("debug", {
                            action: "response",
                            request: n,
                            response: e,
                            provider: this
                        }), t.forEach((t, n) => {
                            let a = e[n];
                            if (a) {
                                if (a.error) {
                                    let e = Error(a.error.message);
                                    e.code = a.error.code, e.data = a.error.data, t.reject(e)
                                } else t.resolve(a.result)
                            } else t.reject(Error("No response for request"))
                        })
                    }, e => {
                        this.emit("debug", {
                            action: "response",
                            error: e,
                            request: n,
                            provider: this
                        }), t.forEach(t => {
                            t.reject(e)
                        })
                    })
                }
                send(e, t) {
                    let n = {
                        method: e,
                        params: t,
                        id: this._nextId++,
                        jsonrpc: "2.0"
                    };
                    null === this._pendingBatch && (this._pendingBatch = []);
                    let a = {
                            request: n,
                            resolve: null,
                            reject: null
                        },
                        r = new Promise((e, t) => {
                            a.resolve = e, a.reject = t
                        });
                    return this._pendingBatch.push(a), this._pendingBatch.length === this._sizeLimit && this.sendCurrentBatch(n), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => {
                        this.sendCurrentBatch(n)
                    }, this._timeLimitMs)), r
                }
            }
            let e7 = N.z.object({
                    rpc: N.z.array(N.z.string().url()),
                    chainId: N.z.number(),
                    nativeCurrency: N.z.object({
                        name: N.z.string(),
                        symbol: N.z.string(),
                        decimals: N.z.number()
                    }),
                    slug: N.z.string()
                }),
                te = N.z.object({
                    supportedChains: N.z.array(e7).default(M.gL9),
                    clientId: N.z.string().optional(),
                    secretKey: N.z.string().optional(),
                    readonlySettings: N.z.object({
                        rpcUrl: N.z.string().url(),
                        chainId: N.z.number().optional()
                    }).optional(),
                    gasSettings: N.z.object({
                        maxPriceInGwei: N.z.number().min(1, "gas price cannot be less than 1").default(300),
                        speed: N.z.enum(["standard", "fast", "fastest"]).default("fastest")
                    }).default({
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }),
                    gasless: N.z.union([N.z.object({
                        openzeppelin: N.z.object({
                            relayerUrl: N.z.string().url(),
                            relayerForwarderAddress: N.z.string().optional(),
                            useEOAForwarder: N.z.boolean().default(!1),
                            domainName: N.z.string().default("GSNv2 Forwarder"),
                            domainVersion: N.z.string().default("0.0.1")
                        }),
                        experimentalChainlessSupport: N.z.boolean().default(!1)
                    }), N.z.object({
                        biconomy: N.z.object({
                            apiId: N.z.string(),
                            apiKey: N.z.string(),
                            deadlineSeconds: N.z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
                        })
                    }), N.z.object({
                        engine: N.z.object({
                            relayerUrl: N.z.string().url().transform(e => e.replace(/\/$/, ""))
                        })
                    })]).optional(),
                    gatewayUrls: N.z.array(N.z.string()).optional()
                }).default({
                    gasSettings: {
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }
                });
            var tt = {
                name: "@thirdweb-dev/sdk",
                version: "4.0.25"
            };

            function tn(e, t) {
                let n;
                if ("string" == typeof e && function(e) {
                        let t = e.match(/^(ws|http)s?:/i);
                        if (t) switch (t[1].toLowerCase()) {
                            case "http":
                            case "https":
                            case "ws":
                            case "wss":
                                return !0
                        }
                        return !1
                    }(e)) return ti(e, t);
                let a = te.parse(t);
                ta(e) && (a.supportedChains = [e, ...a.supportedChains.filter(t => t.chainId === e.chainId)]);
                let r = a.supportedChains.reduce((e, t) => (e[t.chainId] = t, e), {}),
                    i = "";
                try {
                    n = function(e, t) {
                        if (ta(e)) return e.chainId;
                        if ("number" == typeof e) return e; {
                            let n = t.supportedChains.reduce((e, t) => (e[t.slug] = t.chainId, e), {});
                            if (e in n) return n[e]
                        }
                        throw Error(`Cannot resolve chainId from: ${e} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`)
                    }(e, a), i = (0, M.OZ$)(r[n], a.clientId)[0]
                } catch (e) {}
                if (i || (i = `https://${n||e}.rpc.thirdweb.com/${a.clientId||""}`), !i) throw Error(`No rpc url found for chain ${e}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
                return ti(i, t, n)
            }

            function ta(e) {
                return "string" != typeof e && "number" != typeof e && !e8(e) && !e3(e)
            }
            let tr = new Map;

            function ti(e, t, n) {
                try {
                    var a;
                    let r = {},
                        i = "none";
                    if (a = e, new URL(a).hostname.endsWith(".thirdweb.com")) {
                        if (t ? .secretKey) throw Error("Cannot use secretKey in browser context");
                        if (t ? .clientId) {
                            let n = new URL(e);
                            n.pathname = t.clientId, r["x-client-id"] = t.clientId, e = n.toString(), i = "clientId"
                        }
                        "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && (r.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`, i = "twAuthToken"), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && (r["x-authorize-wallet"] = "true");
                        let n = "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
                        e.includes("bundleId") || (e += n ? `?bundleId=${n}` : ""), r["x-sdk-version"] = tt.version, r["x-sdk-name"] = tt.name, r["x-sdk-platform"] = n ? "react-native" : (0, _.jU)() ? void 0 !== window.bridge ? "webGL" : "browser" : "node"
                    }
                    let f = e.match(/^(ws|http)s?:/i);
                    if (f) switch (f[1].toLowerCase()) {
                        case "http":
                        case "https":
                            let s = `${e}-${n||-1}-${i}`,
                                o = tr.get(s);
                            if (o) return o;
                            let c = !1;
                            "undefined" != typeof globalThis && "TW_SKIP_FETCH_SETUP" in globalThis && "boolean" == typeof globalThis.TW_SKIP_FETCH_SETUP && (c = globalThis.TW_SKIP_FETCH_SETUP);
                            let d = n ? new e9({
                                url: e,
                                headers: r,
                                skipFetchSetup: c
                            }, n) : new E.I({
                                url: e,
                                headers: r,
                                skipFetchSetup: c
                            });
                            return tr.set(s, d), d;
                        case "ws":
                        case "wss":
                            return new k.q(e, n)
                    }
                } catch (e) {}
                return A.getDefaultProvider(e)
            }

            function tf(e, t) {
                let n, a;
                if (e8(e) ? (n = e, e.provider && (a = e.provider)) : a = e3(e) ? e : tn(e, t), t ? .readonlySettings && (a = ti(t.readonlySettings.rpcUrl, t, t.readonlySettings.chainId)), !a) {
                    if (n) throw Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
                    throw Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!")
                }
                return [n, a]
            }
            let ts = new Map;
            async function to(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                a || (a = tf("ethereum")[1]), t = ts.has(e) ? ts.get(e) : a.resolveName(e).then(e => e ? {
                    address: e,
                    expirationTime: new Date(Date.now() + 3e5)
                } : {
                    address: null,
                    expirationTime: new Date(Date.now() + 3e4)
                });
                let r = await t;
                return r.expirationTime < new Date && (ts.delete(e), 0 === n && to(e, n + 1)), r.address
            }
            let tc = N.z.custom(e => "string" == typeof e && (e.endsWith(".eth") || e.endsWith(".cb.id"))).transform(async e => to(e)).refine(e => !!e && C.isAddress(e), {
                    message: "Provided value was not a valid ENS name"
                }),
                td = N.z.custom(e => "string" == typeof e && C.isAddress(e), e => ({
                    message: `${e} is not a valid address`
                })),
                tl = N.z.union([td, tc], {
                    invalid_type_error: "Provided value was not a valid address or ENS name"
                });
            async function tu(e) {
                return tl.parseAsync(e)
            }
            let tm = N.z.instanceof(File),
                tp = N.z.union([tm, N.z.object({
                    data: N.z.union([tm, N.z.string()]),
                    name: N.z.string()
                })]),
                tb = N.z.union([tp, N.z.string()]),
                tg = 1e4,
                th = N.z.union([N.z.array(N.z.number()), N.z.string()]),
                ty = N.z.union([N.z.bigint(), N.z.custom(e => v.O$.isBigNumber(e)), N.z.custom(e => W().isBN(e))]).transform(e => W().isBN(e) ? new(W())(e).toString() : v.O$.from(e).toString()),
                tw = N.z.number().max(tg, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                tE = N.z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                tk = N.z.union([N.z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), N.z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform(e => e.replace("#", "")), N.z.string().length(0)]),
                tA = N.z.union([N.z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), N.z.number().min(0, "Amount cannot be negative")]).transform(e => "number" == typeof e ? e.toString() : e),
                tC = N.z.union([tA, N.z.literal("unlimited")]).default("unlimited"),
                tv = "0|[1-9]\\d*",
                tz = RegExp(`(${tv})\\.(${tv})\\.(${tv})`);

            function tF(e) {
                if (e.length > 256) throw Error("version is longer than 256 characters");
                let t = e.trim().match(tz);
                if (!t || t ? .length !== 4) throw Error(`${e} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
                let n = Number(t[1]),
                    a = Number(t[2]),
                    r = Number(t[3]),
                    i = [n, a, r].join(".");
                return {
                    major: n,
                    minor: a,
                    patch: r,
                    versionString: i
                }
            }

            function tx(e, t) {
                let n = tF(e),
                    a = tF(t);
                if (a.major > n.major) return !0;
                let r = a.major === n.major;
                if (r && a.minor > n.minor) return !0;
                let i = a.minor === n.minor;
                return r && i && a.patch > n.patch
            }
            let tT = N.z.union([N.z.string(), N.z.number(), N.z.bigint(), N.z.custom(e => v.O$.isBigNumber(e))]).transform(e => v.O$.from(e)),
                tS = tT.transform(e => e.toString()),
                tP = N.z.union([N.z.bigint(), N.z.custom(e => v.O$.isBigNumber(e))]).transform(e => v.O$.from(e).toString()),
                tB = N.z.object({
                    name: N.z.string(),
                    description: N.z.string().optional(),
                    image: tb.optional(),
                    external_link: N.z.string().optional(),
                    app_uri: N.z.string().optional(),
                    social_urls: N.z.record(N.z.string()).optional()
                }).catchall(N.z.unknown()),
                tR = tB.extend({
                    image: N.z.string().optional()
                }).catchall(N.z.unknown()),
                tO = N.z.object({
                    seller_fee_basis_points: tw.default(0),
                    fee_recipient: tl.default(z.d)
                }),
                tD = N.z.object({
                    primary_sale_recipient: tl.default(z.d)
                }),
                t$ = N.z.object({
                    platform_fee_basis_points: tw.default(0),
                    platform_fee_recipient: tl.default(z.d)
                }),
                tI = N.z.object({
                    trusted_forwarders: N.z.array(tl).default([])
                }),
                tL = N.z.object({
                    symbol: N.z.string().default("")
                }),
                tN = N.z.object({
                    merkle: N.z.record(N.z.string()).default({})
                }),
                tM = N.z.object({
                    address: tl,
                    maxClaimable: tC.default(0),
                    price: tC.optional(),
                    currencyAddress: tl.default(z.d).optional()
                }),
                t_ = N.z.union([N.z.array(N.z.string()).transform(async e => await Promise.all(e.map(e => tM.parseAsync({
                    address: e
                })))), N.z.array(tM)]),
                tj = tM.extend({
                    proof: N.z.array(N.z.string())
                }),
                tU = N.z.object({
                    merkleRoot: N.z.string(),
                    claims: N.z.array(tj)
                }),
                tW = tB.catchall(N.z.union([tP, N.z.unknown()])).merge(tO.merge(tN).merge(tL).partial()).catchall(N.z.any()),
                tG = tR.merge(tO.merge(tN).merge(tL).partial()).catchall(N.z.any()),
                tH = {
                    deploy: tW.merge(t$.merge(tD).merge(tI).partial()),
                    output: tG,
                    input: tW
                },
                tV = N.z.object({
                    type: N.z.string(),
                    name: N.z.string().default("")
                }).catchall(N.z.any()),
                tK = tV.extend({
                    stateMutability: N.z.string().optional(),
                    components: N.z.array(tV).optional()
                }).catchall(N.z.any()),
                tZ = N.z.object({
                    type: N.z.string(),
                    name: N.z.string().default(""),
                    inputs: N.z.array(tK).default([]),
                    outputs: N.z.array(tK).default([])
                }).catchall(N.z.any()),
                tJ = N.z.array(tZ),
                tq = N.z.object({
                    name: N.z.string(),
                    metadataUri: N.z.string(),
                    bytecodeUri: N.z.string(),
                    analytics: N.z.any().optional()
                }).catchall(N.z.any()),
                tY = N.z.record(N.z.string(), N.z.string()),
                tX = N.z.object({
                    factoryFunction: N.z.string(),
                    params: N.z.array(N.z.object({
                        name: N.z.string(),
                        type: N.z.string()
                    })).default([]),
                    customFactoryAddresses: tY
                }),
                tQ = N.z.object({
                    implementationAddresses: tY,
                    implementationInitializerFunction: N.z.string().default("initialize"),
                    customFactoryInput: tX.optional(),
                    factoryAddresses: tY.optional()
                }),
                t0 = N.z.union([N.z.literal("standard"), N.z.literal("autoFactory"), N.z.literal("customFactory")]),
                t1 = N.z.union([N.z.literal("none"), N.z.literal("plugin"), N.z.literal("dynamic")]),
                t6 = N.z.object({
                    allNetworks: N.z.boolean().optional(),
                    networksEnabled: N.z.array(N.z.number()).default([])
                }),
                t5 = N.z.object({
                    version: N.z.string().refine(e => {
                        try {
                            return tF(e), !0
                        } catch (e) {
                            return !1
                        }
                    }, e => ({
                        message: `'${e}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
                    })),
                    displayName: N.z.string().optional(),
                    description: N.z.string().optional(),
                    readme: N.z.string().optional(),
                    license: N.z.string().optional(),
                    changelog: N.z.string().optional(),
                    tags: N.z.array(N.z.string()).optional(),
                    audit: tb.nullable().optional(),
                    logo: tb.nullable().optional(),
                    isDeployableViaFactory: N.z.boolean().optional(),
                    isDeployableViaProxy: N.z.boolean().optional(),
                    factoryDeploymentData: tQ.optional(),
                    deployType: t0.optional(),
                    routerType: t1.optional(),
                    defaultExtensions: N.z.array(N.z.object({
                        extensionName: N.z.string(),
                        extensionVersion: N.z.string().default("latest"),
                        publisherAddress: tl
                    })).optional(),
                    networksForDeployment: t6.optional(),
                    constructorParams: N.z.record(N.z.string(), N.z.object({
                        displayName: N.z.string().optional(),
                        description: N.z.string().optional(),
                        defaultValue: N.z.string().optional(),
                        hidden: N.z.boolean().optional()
                    }).catchall(N.z.any())).optional(),
                    compositeAbi: tJ.optional()
                }).catchall(N.z.any()),
                t2 = t5.extend({
                    audit: N.z.string().nullable().optional(),
                    logo: N.z.string().nullable().optional()
                }),
                t8 = tq.merge(t5).extend({
                    publisher: tl.optional()
                }),
                t3 = tq.merge(t2).extend({
                    publisher: tl.optional()
                }),
                t4 = N.z.object({
                    name: N.z.string().optional(),
                    bio: N.z.string().optional(),
                    avatar: tb.nullable().optional(),
                    website: N.z.string().optional(),
                    twitter: N.z.string().optional(),
                    telegram: N.z.string().optional(),
                    facebook: N.z.string().optional(),
                    github: N.z.string().optional(),
                    medium: N.z.string().optional(),
                    linkedin: N.z.string().optional(),
                    reddit: N.z.string().optional(),
                    discord: N.z.string().optional()
                }).extend({
                    avatar: N.z.string().nullable().optional()
                }),
                t9 = N.z.object({
                    id: N.z.string(),
                    timestamp: tS,
                    metadataUri: N.z.string()
                }),
                t7 = N.z.object({
                    title: N.z.string().optional(),
                    author: N.z.string().optional(),
                    details: N.z.string().optional(),
                    notice: N.z.string().optional()
                }),
                ne = N.z.object({
                    name: N.z.string(),
                    abi: tJ,
                    metadata: N.z.record(N.z.string(), N.z.any()),
                    info: t7,
                    licenses: N.z.array(N.z.string().optional()).default([]).transform(e => e.filter(e => void 0 !== e)),
                    isPartialAbi: N.z.boolean().optional()
                }),
                nt = tq.merge(ne).extend({
                    bytecode: N.z.string()
                });
            async function nn(e, t) {
                let n = await (await t.download(e)).text();
                return t3.parse(JSON.parse(n))
            }
            async function na(e, t) {
                let n = await t.downloadJSON(e, {
                    timeoutInSeconds: 2
                });
                if (!n || !n.output) throw Error(`Could not resolve metadata for contract at ${e}`);
                return nr(n)
            }

            function nr(e) {
                let t = tJ.parse(e.output.abi),
                    n = e.settings.compilationTarget,
                    a = Object.keys(n),
                    r = n[a[0]],
                    i = t7.parse({
                        title: e.output.devdoc.title,
                        author: e.output.devdoc.author,
                        details: e.output.devdoc.detail,
                        notice: e.output.userdoc.notice
                    }),
                    f = [...new Set(Object.entries(e.sources).map(e => {
                        let [, t] = e;
                        return t.license
                    }))];
                return {
                    name: r,
                    abi: t,
                    metadata: e,
                    info: i,
                    licenses: f,
                    isPartialAbi: e.isPartialAbi
                }
            }
            async function ni(e, t) {
                return tq.parse(JSON.parse(await (await t.download(e)).text()))
            }
            async function nf(e, t) {
                let n = await ni(e, t),
                    a = await (await t.download(n.bytecodeUri)).text(),
                    r = await na(n.metadataUri, t);
                return nt.parse({ ...n,
                    ...r,
                    bytecode: a
                })
            }
            let ns = {};
            async function no(e, t) {
                let n;
                if (ns[e]) return ns[e];
                let a = await nf(e, t);
                try {
                    n = await nn(e, t)
                } catch (e) {}
                let r = {
                    compilerMetadata: a,
                    extendedMetadata: n
                };
                return ns[e] = r, r
            }
            let nc = M.gL9;

            function nd(e) {
                nc = e && e.length > 0 ? e : M.gL9
            }
            let nl = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
            async function nu(e, t) {
                let a, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                    i = arguments.length > 3 ? arguments[3] : void 0,
                    f = arguments.length > 4 ? arguments[4] : void 0,
                    s = arguments.length > 5 ? arguments[5] : void 0,
                    o = nc.find(e => 137 === e.chainId) || M.mgq,
                    c = await tu(e),
                    d = (await Promise.resolve().then(n.t.bind(n, 46762, 19))).default,
                    l = new F.CH(e2(), d, tn(o, {
                        clientId: f,
                        secretKey: s
                    }));
                if (r && "latest" !== r) {
                    let e = (await l.getPublishedContractVersions(c, t)).map(e => t9.parse({
                            id: e.contractId,
                            timestamp: e.publishTimestamp,
                            metadataUri: e.publishMetadataUri
                        })),
                        n = (await Promise.all(e.map(e => no(e.metadataUri, i)))).map((t, n) => ({
                            name: e[n].id,
                            publishedTimestamp: e[n].timestamp,
                            publishedMetadata: t
                        })).find(e => e.publishedMetadata.extendedMetadata ? .version === r);
                    (0, j.Z)(n, "Contract version not found"), a = e.find(e => e.timestamp === n.publishedTimestamp)
                } else {
                    let e = await l.getPublishedContract(c, t);
                    a = t9.parse({
                        id: e.contractId,
                        timestamp: e.publishTimestamp,
                        metadataUri: e.publishMetadataUri
                    })
                }
                if (!a) throw Error(`No published contract found for ${t} at version by '${nl}'`);
                return a
            }
            async function nm(e, t) {
                try {
                    let a = (await n.e(4939).then(n.t.bind(n, 74939, 19))).default,
                        r = new F.CH(e, a, t),
                        [i, f] = await Promise.all([r.contractType(), r.contractVersion()]);
                    return {
                        type: x.ZN(i).replace(/\x00/g, ""),
                        version: f
                    }
                } catch (e) {
                    return
                }
            }
            try {
                r = new TextDecoder
            } catch (e) {}
            let np = 0,
                nb = {},
                ng = {},
                nh = 0,
                ny = 0,
                nw = [],
                nE = [],
                nk = {
                    useRecords: !1,
                    mapsAsObjects: !0
                },
                nA = !1;
            class nC {
                constructor(e) {
                    if (e && ((e.keyMap || e._keyMap) && !e.useRecords && (e.useRecords = !1, e.mapsAsObjects = !0), !1 === e.useRecords && void 0 === e.mapsAsObjects && (e.mapsAsObjects = !0), e.getStructures && (e.getShared = e.getStructures), e.getShared && !e.structures && ((e.structures = []).uninitialized = !0), e.keyMap))
                        for (let [t, n] of (this.mapKey = new Map, Object.entries(e.keyMap))) this.mapKey.set(n, t);
                    Object.assign(this, e)
                }
                decodeKey(e) {
                    return this.keyMap && this.mapKey.get(e) || e
                }
                decode(e, t) {
                    if (i) return nH(() => (nV(), this ? this.decode(e, t) : nC.prototype.decode.call(nk, e, t)));
                    f = t > -1 ? t : e.length, np = 0, ny = 0, o = null, c = null, i = e;
                    try {
                        u = e.dataView || (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength))
                    } catch (t) {
                        if (i = null, e instanceof Uint8Array) throw t;
                        throw Error("Source must be a Uint8Array or Buffer but was a " + (e && "object" == typeof e ? e.constructor.name : typeof e))
                    }
                    return this instanceof nC ? (ng = this, l = this.sharedValues && (this.pack ? Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues), this.structures ? s = this.structures : (!s || s.length > 0) && (s = [])) : (ng = nk, (!s || s.length > 0) && (s = []), l = null),
                        function() {
                            try {
                                let e = nv();
                                if (c) {
                                    if (np >= c.postBundlePosition) {
                                        let e = Error("Unexpected bundle position");
                                        throw e.incomplete = !0, e
                                    }
                                    np = c.postBundlePosition, c = null
                                }
                                if (np == f) s = null, i = null, d && (d = null);
                                else if (np > f) {
                                    let e = Error("Unexpected end of CBOR data");
                                    throw e.incomplete = !0, e
                                } else if (!nA) throw Error("Data read, but end of buffer not reached");
                                return e
                            } catch (e) {
                                throw nV(), (e instanceof RangeError || e.message.startsWith("Unexpected end of buffer")) && (e.incomplete = !0), e
                            }
                        }()
                }
            }

            function nv() {
                let e = i[np++],
                    t = e >> 5;
                if ((e &= 31) > 23) switch (e) {
                    case 24:
                        e = i[np++];
                        break;
                    case 25:
                        if (7 == t) return function() {
                            let e = i[np++],
                                t = i[np++],
                                n = (127 & e) >> 2;
                            if (31 === n) return t || 3 & e ? NaN : 128 & e ? -1 / 0 : 1 / 0;
                            if (0 === n) {
                                let n = ((3 & e) << 8 | t) / 16777216;
                                return 128 & e ? -n : n
                            }
                            return nO[3] = 128 & e | (n >> 1) + 56, nO[2] = (7 & e) << 5 | t >> 3, nO[1] = t << 5, nO[0] = 0, nR[0]
                        }();
                        e = u.getUint16(np), np += 2;
                        break;
                    case 26:
                        if (7 == t) {
                            let e = u.getFloat32(np);
                            if (ng.useFloat32 > 2) {
                                let t = nK[(127 & i[np]) << 1 | i[np + 1] >> 7];
                                return np += 4, (t * e + (e > 0 ? .5 : -.5) >> 0) / t
                            }
                            return np += 4, e
                        }
                        e = u.getUint32(np), np += 4;
                        break;
                    case 27:
                        if (7 == t) {
                            let e = u.getFloat64(np);
                            return np += 8, e
                        }
                        if (t > 1) {
                            if (u.getUint32(np) > 0) throw Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
                            e = u.getUint32(np + 4)
                        } else e = ng.int64AsNumber ? 4294967296 * u.getUint32(np) + u.getUint32(np + 4) : u.getBigUint64(np);
                        np += 8;
                        break;
                    case 31:
                        switch (t) {
                            case 2:
                            case 3:
                                throw Error("Indefinite length not supported for byte or text strings");
                            case 4:
                                let n = [],
                                    a, r = 0;
                                for (;
                                    (a = nv()) != nb;) n[r++] = a;
                                return 4 == t ? n : 3 == t ? n.join("") : e6.concat(n);
                            case 5:
                                let d;
                                if (ng.mapsAsObjects) {
                                    let e = {};
                                    if (ng.keyMap)
                                        for (;
                                            (d = nv()) != nb;) e[nx(ng.decodeKey(d))] = nv();
                                    else
                                        for (;
                                            (d = nv()) != nb;) e[nx(d)] = nv();
                                    return e
                                } {
                                    m && (ng.mapsAsObjects = !0, m = !1);
                                    let e = new Map;
                                    if (ng.keyMap)
                                        for (;
                                            (d = nv()) != nb;) e.set(ng.decodeKey(d), nv());
                                    else
                                        for (;
                                            (d = nv()) != nb;) e.set(d, nv());
                                    return e
                                }
                            case 7:
                                return nb;
                            default:
                                throw Error("Invalid major type for indefinite length " + t)
                        }
                    default:
                        throw Error("Unknown token " + e)
                }
                switch (t) {
                    case 0:
                        return e;
                    case 1:
                        return ~e;
                    case 2:
                        var p;
                        return p = e, ng.copyBuffers ? Uint8Array.prototype.slice.call(i, np, np += p) : i.subarray(np, np += p);
                    case 3:
                        if (ny >= np) return o.slice(np - nh, (np += e) - nh);
                        if (0 == ny && f < 140 && e < 32) {
                            let t = e < 16 ? nB(e) : function(e) {
                                let t = np,
                                    n = Array(e);
                                for (let a = 0; a < e; a++) {
                                    let e = i[np++];
                                    if ((128 & e) > 0) {
                                        np = t;
                                        return
                                    }
                                    n[a] = e
                                }
                                return nP.apply(String, n)
                            }(e);
                            if (null != t) return t
                        }
                        return nT(e);
                    case 4:
                        let b = Array(e);
                        for (let t = 0; t < e; t++) b[t] = nv();
                        return b;
                    case 5:
                        if (ng.mapsAsObjects) {
                            let t = {};
                            if (ng.keyMap)
                                for (let n = 0; n < e; n++) t[nx(ng.decodeKey(nv()))] = nv();
                            else
                                for (let n = 0; n < e; n++) t[nx(nv())] = nv();
                            return t
                        } {
                            m && (ng.mapsAsObjects = !0, m = !1);
                            let t = new Map;
                            if (ng.keyMap)
                                for (let n = 0; n < e; n++) t.set(ng.decodeKey(nv()), nv());
                            else
                                for (let n = 0; n < e; n++) t.set(nv(), nv());
                            return t
                        }
                    case 6:
                        if (e >= 57337) {
                            let t = s[8191 & e];
                            if (t) return t.read || (t.read = nF(t)), t.read();
                            if (e < 65536) {
                                if (57343 == e) return n$(nv());
                                if (57342 == e) {
                                    let e = nW(),
                                        t = nv();
                                    for (let n = 2; n < e; n++) n$([t++, nv()]);
                                    return nv()
                                }
                                if (57337 == e) return function() {
                                    let e = nW(),
                                        t = np + nv();
                                    for (let t = 2; t < e; t++) {
                                        let e = nW();
                                        np += e
                                    }
                                    let n = np;
                                    return np = t, (c = [nS(nW()), nS(nW())]).position0 = 0, c.position1 = 0, c.postBundlePosition = np, np = n, nv()
                                }();
                                if (ng.getShared && (nG(), t = s[8191 & e])) return t.read || (t.read = nF(t)), t.read()
                            }
                        }
                        let g = nw[e];
                        if (g) {
                            if (g.handlesRead) return g(nv);
                            return g(nv())
                        } {
                            let t = nv();
                            for (let n = 0; n < nE.length; n++) {
                                let a = nE[n](e, t);
                                if (void 0 !== a) return a
                            }
                            return new nD(t, e)
                        }
                    case 7:
                        switch (e) {
                            case 20:
                                return !1;
                            case 21:
                                return !0;
                            case 22:
                                return null;
                            case 23:
                                return;
                            default:
                                let h = (l || nM())[e];
                                if (void 0 !== h) return h;
                                throw Error("Unknown token " + e)
                        }
                    default:
                        if (isNaN(e)) {
                            let e = Error("Unexpected end of CBOR data");
                            throw e.incomplete = !0, e
                        }
                        throw Error("Unknown CBOR token " + e)
                }
            }
            let nz = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;

            function nF(e) {
                return e.slowReads = 0,
                    function() {
                        let e = i[np++];
                        if ((e &= 31) > 23) switch (e) {
                            case 24:
                                e = i[np++];
                                break;
                            case 25:
                                e = u.getUint16(np), np += 2;
                                break;
                            case 26:
                                e = u.getUint32(np), np += 4;
                                break;
                            default:
                                throw Error("Expected array header, but got " + i[np - 1])
                        }
                        let t = this.compiledReader;
                        for (; t;) {
                            if (t.propertyCount === e) return t(nv);
                            t = t.next
                        }
                        if (this.slowReads++ >= 3) {
                            let n = this.length == e ? this : this.slice(0, e);
                            return t = ng.keyMap ? Function("r", "return {" + n.map(e => ng.decodeKey(e)).map(e => nz.test(e) ? nx(e) + ":r()" : "[" + JSON.stringify(e) + "]:r()").join(",") + "}") : Function("r", "return {" + n.map(e => nz.test(e) ? nx(e) + ":r()" : "[" + JSON.stringify(e) + "]:r()").join(",") + "}"), this.compiledReader && (t.next = this.compiledReader), t.propertyCount = e, this.compiledReader = t, t(nv)
                        }
                        let n = {};
                        if (ng.keyMap)
                            for (let t = 0; t < e; t++) n[nx(ng.decodeKey(this[t]))] = nv();
                        else
                            for (let t = 0; t < e; t++) n[nx(this[t])] = nv();
                        return n
                    }
            }

            function nx(e) {
                return "__proto__" === e ? "__proto_" : e
            }
            let nT = nS;

            function nS(e) {
                let t;
                if (e < 16 && (t = nB(e))) return t;
                if (e > 64 && r) return r.decode(i.subarray(np, np += e));
                let n = np + e,
                    a = [];
                for (t = ""; np < n;) {
                    let e = i[np++];
                    if ((128 & e) == 0) a.push(e);
                    else if ((224 & e) == 192) {
                        let t = 63 & i[np++];
                        a.push((31 & e) << 6 | t)
                    } else if ((240 & e) == 224) {
                        let t = 63 & i[np++],
                            n = 63 & i[np++];
                        a.push((31 & e) << 12 | t << 6 | n)
                    } else if ((248 & e) == 240) {
                        let t = (7 & e) << 18 | (63 & i[np++]) << 12 | (63 & i[np++]) << 6 | 63 & i[np++];
                        t > 65535 && (t -= 65536, a.push(t >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), a.push(t)
                    } else a.push(e);
                    a.length >= 4096 && (t += nP.apply(String, a), a.length = 0)
                }
                return a.length > 0 && (t += nP.apply(String, a)), t
            }
            let nP = String.fromCharCode;

            function nB(e) {
                if (e < 4) {
                    if (e < 2) {
                        if (0 === e) return ""; {
                            let e = i[np++];
                            if ((128 & e) > 1) {
                                np -= 1;
                                return
                            }
                            return nP(e)
                        }
                    } {
                        let t = i[np++],
                            n = i[np++];
                        if ((128 & t) > 0 || (128 & n) > 0) {
                            np -= 2;
                            return
                        }
                        if (e < 3) return nP(t, n);
                        let a = i[np++];
                        if ((128 & a) > 0) {
                            np -= 3;
                            return
                        }
                        return nP(t, n, a)
                    }
                } {
                    let t = i[np++],
                        n = i[np++],
                        a = i[np++],
                        r = i[np++];
                    if ((128 & t) > 0 || (128 & n) > 0 || (128 & a) > 0 || (128 & r) > 0) {
                        np -= 4;
                        return
                    }
                    if (e < 6) {
                        if (4 === e) return nP(t, n, a, r); {
                            let e = i[np++];
                            if ((128 & e) > 0) {
                                np -= 5;
                                return
                            }
                            return nP(t, n, a, r, e)
                        }
                    }
                    if (e < 8) {
                        let f = i[np++],
                            s = i[np++];
                        if ((128 & f) > 0 || (128 & s) > 0) {
                            np -= 6;
                            return
                        }
                        if (e < 7) return nP(t, n, a, r, f, s);
                        let o = i[np++];
                        if ((128 & o) > 0) {
                            np -= 7;
                            return
                        }
                        return nP(t, n, a, r, f, s, o)
                    } {
                        let f = i[np++],
                            s = i[np++],
                            o = i[np++],
                            c = i[np++];
                        if ((128 & f) > 0 || (128 & s) > 0 || (128 & o) > 0 || (128 & c) > 0) {
                            np -= 8;
                            return
                        }
                        if (e < 10) {
                            if (8 === e) return nP(t, n, a, r, f, s, o, c); {
                                let e = i[np++];
                                if ((128 & e) > 0) {
                                    np -= 9;
                                    return
                                }
                                return nP(t, n, a, r, f, s, o, c, e)
                            }
                        }
                        if (e < 12) {
                            let d = i[np++],
                                l = i[np++];
                            if ((128 & d) > 0 || (128 & l) > 0) {
                                np -= 10;
                                return
                            }
                            if (e < 11) return nP(t, n, a, r, f, s, o, c, d, l);
                            let u = i[np++];
                            if ((128 & u) > 0) {
                                np -= 11;
                                return
                            }
                            return nP(t, n, a, r, f, s, o, c, d, l, u)
                        } {
                            let d = i[np++],
                                l = i[np++],
                                u = i[np++],
                                m = i[np++];
                            if ((128 & d) > 0 || (128 & l) > 0 || (128 & u) > 0 || (128 & m) > 0) {
                                np -= 12;
                                return
                            }
                            if (e < 14) {
                                if (12 === e) return nP(t, n, a, r, f, s, o, c, d, l, u, m); {
                                    let e = i[np++];
                                    if ((128 & e) > 0) {
                                        np -= 13;
                                        return
                                    }
                                    return nP(t, n, a, r, f, s, o, c, d, l, u, m, e)
                                }
                            } {
                                let p = i[np++],
                                    b = i[np++];
                                if ((128 & p) > 0 || (128 & b) > 0) {
                                    np -= 14;
                                    return
                                }
                                if (e < 15) return nP(t, n, a, r, f, s, o, c, d, l, u, m, p, b);
                                let g = i[np++];
                                if ((128 & g) > 0) {
                                    np -= 15;
                                    return
                                }
                                return nP(t, n, a, r, f, s, o, c, d, l, u, m, p, b, g)
                            }
                        }
                    }
                }
            }
            let nR = new Float32Array(1),
                nO = new Uint8Array(nR.buffer, 0, 4);
            class nD {
                constructor(e, t) {
                    this.value = e, this.tag = t
                }
            }
            nw[0] = e => new Date(e), nw[1] = e => new Date(Math.round(1e3 * e)), nw[2] = e => {
                let t = BigInt(0);
                for (let n = 0, a = e.byteLength; n < a; n++) t = BigInt(e[n]) + t << BigInt(8);
                return t
            }, nw[3] = e => BigInt(-1) - nw[2](e), nw[4] = e => Number(e[1] + "e" + e[0]), nw[5] = e => e[1] * Math.exp(e[0] * Math.log(2));
            let n$ = e => {
                let t = e[0] - 57344,
                    n = e[1],
                    a = s[t];
                a && a.isShared && ((s.restoreStructures || (s.restoreStructures = []))[t] = a), s[t] = n, n.read = nF(n);
                let r = {};
                if (ng.keyMap)
                    for (let t = 2, a = e.length; t < a; t++) r[nx(ng.decodeKey(n[t - 2]))] = e[t];
                else
                    for (let t = 2, a = e.length; t < a; t++) r[nx(n[t - 2])] = e[t];
                return r
            };
            nw[105] = n$, nw[14] = e => c ? c[0].slice(c.position0, c.position0 += e) : new nD(e, 14), nw[15] = e => c ? c[1].slice(c.position1, c.position1 += e) : new nD(e, 15);
            let nI = {
                Error,
                RegExp
            };
            nw[27] = e => (nI[e[0]] || Error)(e[1], e[2]);
            let nL = e => {
                if (132 != i[np++]) throw Error("Packed values structure must be followed by a 4 element array");
                let t = e();
                return (l = l ? t.concat(l.slice(t.length)) : t).prefixes = e(), l.suffixes = e(), e()
            };

            function nN(e, t) {
                return "string" == typeof e ? e + t : e instanceof Array ? e.concat(t) : Object.assign({}, e, t)
            }

            function nM() {
                if (!l) {
                    if (ng.getShared) nG();
                    else throw Error("No packed values available")
                }
                return l
            }
            nL.handlesRead = !0, nw[51] = nL, nw[6] = e => {
                if (!l) {
                    if (!ng.getShared) return new nD(e, 6);
                    nG()
                }
                if ("number" == typeof e) return l[16 + (e >= 0 ? 2 * e : -2 * e - 1)];
                throw Error("No support for non-integer packed references yet")
            }, nw[25] = e => stringRefs[e], nw[256] = e => {
                stringRefs = [];
                try {
                    return e()
                } finally {
                    stringRefs = null
                }
            }, nw[256].handlesRead = !0, nw[28] = e => {
                let t;
                d || ((d = new Map).id = 0);
                let n = d.id++,
                    a = {
                        target: t = i[np] >> 5 == 4 ? [] : {}
                    };
                d.set(n, a);
                let r = e();
                return a.used ? Object.assign(t, r) : (a.target = r, r)
            }, nw[28].handlesRead = !0, nw[29] = e => {
                let t = d.get(e);
                return t.used = !0, t.target
            }, nw[258] = e => new Set(e), (nw[259] = e => (ng.mapsAsObjects && (ng.mapsAsObjects = !1, m = !0), e())).handlesRead = !0, nE.push((e, t) => e >= 225 && e <= 255 ? nN(nM().prefixes[e - 224], t) : e >= 28704 && e <= 32767 ? nN(nM().prefixes[e - 28672], t) : e >= 1879052288 && e <= 2147483647 ? nN(nM().prefixes[e - 1879048192], t) : e >= 216 && e <= 223 ? nN(t, nM().suffixes[e - 216]) : e >= 27647 && e <= 28671 ? nN(t, nM().suffixes[e - 27639]) : e >= 1811940352 && e <= 1879048191 ? nN(t, nM().suffixes[e - 1811939328]) : 1399353956 == e ? {
                packedValues: l,
                structures: s.slice(0),
                version: t
            } : 55799 == e ? t : void 0);
            let n_ = 1 == new Uint8Array(new Uint16Array([1]).buffer)[0],
                nj = [Uint8Array],
                nU = [64];
            for (let e = 0; e < nj.length; e++) ! function(e, t) {
                let n = "get" + e.name.slice(0, -5);
                "function" != typeof e && (e = null);
                let a = e.BYTES_PER_ELEMENT;
                for (let r = 0; r < 2; r++) {
                    if (!r && 1 == a) continue;
                    let i = 2 == a ? 1 : 4 == a ? 2 : 3;
                    nw[r ? t : t - 4] = 1 == a || r == n_ ? n => {
                        if (!e) throw Error("Could not find typed array for code " + t);
                        return new e(Uint8Array.prototype.slice.call(n, 0).buffer)
                    } : a => {
                        if (!e) throw Error("Could not find typed array for code " + t);
                        let f = new DataView(a.buffer, a.byteOffset, a.byteLength),
                            s = a.length >> i,
                            o = new e(s),
                            c = f[n];
                        for (let e = 0; e < s; e++) o[e] = c.call(f, e << i, r);
                        return o
                    }
                }
            }(nj[e], nU[e]);

            function nW() {
                let e = 31 & i[np++];
                if (e > 23) switch (e) {
                    case 24:
                        e = i[np++];
                        break;
                    case 25:
                        e = u.getUint16(np), np += 2;
                        break;
                    case 26:
                        e = u.getUint32(np), np += 4
                }
                return e
            }

            function nG() {
                if (ng.getShared) {
                    let e = nH(() => (i = null, ng.getShared())) || {},
                        t = e.structures || [];
                    ng.sharedVersion = e.version, l = ng.sharedValues = e.packedValues, !0 === s ? ng.structures = s = t : s.splice.apply(s, [0, t.length].concat(t))
                }
            }

            function nH(e) {
                let t = f,
                    n = np,
                    a = nh,
                    r = ny,
                    l = o,
                    m = d,
                    p = c,
                    b = new Uint8Array(i.slice(0, f)),
                    g = s,
                    h = ng,
                    y = nA,
                    w = e();
                return f = t, np = n, nh = a, ny = r, o = l, d = m, c = p, i = b, nA = y, s = g, ng = h, u = new DataView(i.buffer, i.byteOffset, i.byteLength), w
            }

            function nV() {
                i = null, d = null, s = null
            }
            let nK = Array(147);
            for (let e = 0; e < 256; e++) nK[e] = Number("1e" + Math.floor(45.15 - .30103 * e));
            let nZ = new nC({
                useRecords: !1
            }).decode;

            function nJ(e) {
                let t = function(e) {
                        var t;
                        if ((e = e.toString(16)).startsWith("0x") || (e = `0x${e}`), !(("string" == typeof(t = e) || "number" == typeof t) && /^(-)?0x[0-9a-f]*$/i.test(t.toString()))) throw Error(`Given value "${e}" is not a valid hex string.`);
                        e = e.replace(/^0x/i, "");
                        let n = [];
                        for (let t = 0; t < e.length; t += 2) n.push(parseInt(e.slice(t, t + 2), 16));
                        return n
                    }(e),
                    n = 256 * t[t.length - 2] + t[t.length - 1],
                    a = nZ(Uint8Array.from(t.slice(t.length - 2 - n, -2)));
                if ("ipfs" in a && a.ipfs) try {
                    return `ipfs://${H().encode(a.ipfs)}`
                } catch (e) {
                    console.warn("feature-detection ipfs cbor failed", e)
                }
            }
            async function nq(e, t) {
                let {
                    bytecode: n
                } = await nX(e, t);
                return nJ(n)
            }
            async function nY(e, t) {
                let {
                    bytecode: n
                } = await nX(e, t);
                return {
                    uri: nJ(n),
                    bytecode: n
                }
            }
            async function nX(e, t) {
                let n = await nQ(e, t),
                    a = function(e) {
                        if (e.startsWith("0x363d3d373d3d3d363d73")) {
                            let t = e.slice(22, 62);
                            return `0x${t}`
                        }
                        if (e.startsWith("0x36603057343d5230")) {
                            let t = e.slice(122, 162);
                            return `0x${t}`
                        }
                        if (e.startsWith("0x3d3d3d3d363d3d37363d73")) {
                            let t = e.slice(24, 64);
                            return `0x${t}`
                        }
                        if (e.startsWith("0x366000600037611000600036600073")) {
                            let t = e.slice(32, 72);
                            return `0x${t}`
                        }
                    }(n);
                if (a) return {
                    address: a,
                    bytecode: await nQ(a, t)
                };
                for (let n of (await Promise.all([n0(e, t), n1(e, t)])))
                    if (n && C.isAddress(n) && n !== z.d) return {
                        address: n,
                        bytecode: await nQ(n, t)
                    };
                return {
                    address: e,
                    bytecode: n
                }
            }
            async function nQ(e, t) {
                try {
                    let n = await t.getCode(e);
                    if ("0x" === n) {
                        let n = await t.getNetwork();
                        throw Error(`Contract at ${e} does not exist on chain '${n.name}' (chainId: ${n.chainId})`)
                    }
                    return n
                } catch (t) {
                    throw Error(`Failed to get bytecode for address ${e}: ${t}`)
                }
            }
            async function n0(e, t) {
                try {
                    let n = await t.getStorageAt(e, v.O$.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
                    return `0x${n.slice(-40)}`
                } catch (e) {
                    return
                }
            }
            async function n1(e, t) {
                try {
                    let n = new F.CH(e, n6, t);
                    return await n.implementation()
                } catch (e) {
                    return
                }
            }
            let n6 = [{
                type: "function",
                name: "implementation",
                inputs: [],
                outputs: [{
                    type: "address",
                    name: "",
                    internalType: "address"
                }],
                stateMutability: "view"
            }];

            function n5() {
                return e5("multiChainRegistryAddress", "0xcdAD8FA86e18538aC207872E8ff3536501431B73")
            }
            let n2 = () => !0,
                n8 = () => !n2();

            function n3(e, t) {
                let n = e.map(e => tJ.parse(e)).flat().filter(e => "constructor" !== e.type);
                t && n.push(...tJ.parse(t));
                let a = function(e, t) {
                    if (0 === e.length || 1 === e.length || !t) return e;
                    for (let n = 0; n < e.length; n++)
                        for (let a = n + 1; a < e.length; a++) t(e[n], e[a]) && e.splice(a, 1);
                    return e
                }(n, (e, t) => e.name === t.name && e.type === t.type && e.inputs.length === t.inputs.length);
                return tJ.parse(a)
            }
            let n4 = {
                    name: "ERC20ClaimConditionsV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [Y, q],
                    features: {}
                },
                n9 = {
                    name: "ERC20ClaimConditionsV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [Y, J],
                    features: {}
                },
                n7 = {
                    name: "ERC20ClaimPhasesV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [Y, K],
                    features: {}
                },
                ae = {
                    name: "ERC20ClaimPhasesV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [Z],
                    features: {}
                },
                at = {
                    name: "ERC20Burnable",
                    namespace: "token.burn",
                    docLinks: {
                        sdk: "sdk.erc20burnable",
                        contracts: "erc20burnable"
                    },
                    abis: [Y, V],
                    features: {}
                },
                an = {
                    name: "ERC20SignatureMintable",
                    namespace: "token.signature",
                    docLinks: {
                        sdk: "sdk.erc20signaturemintable",
                        contracts: "erc20signaturemint"
                    },
                    abis: [Y, et],
                    features: {}
                },
                aa = {
                    name: "ERC20BatchMintable",
                    namespace: "token.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc20batchmintable",
                        contracts: "erc20batchmintable"
                    },
                    abis: [Y, Q, ee],
                    features: {}
                },
                ar = {
                    name: "ERC20Mintable",
                    namespace: "token.mint",
                    docLinks: {
                        sdk: "sdk.erc20mintable",
                        contracts: "erc20mintable"
                    },
                    abis: [Y, Q],
                    features: {
                        [aa.name]: aa
                    }
                },
                ai = {
                    name: "ERC20Permit",
                    namespace: "token.permit",
                    docLinks: {
                        sdk: "sdk.erc20permit",
                        contracts: "erc20permit"
                    },
                    abis: [Y, X],
                    features: {}
                },
                af = {
                    name: "ERC20",
                    namespace: "token",
                    docLinks: {
                        sdk: "sdk.erc20",
                        contracts: "erc20"
                    },
                    abis: [Y, en],
                    features: {
                        [at.name]: at,
                        [ar.name]: ar,
                        [n4.name]: n4,
                        [n9.name]: n9,
                        [ae.name]: ae,
                        [n7.name]: n7,
                        [an.name]: an,
                        [ai.name]: ai
                    }
                },
                as = {
                    name: "ERC721Burnable",
                    namespace: "nft.burn",
                    docLinks: {
                        sdk: "sdk.erc721burnable",
                        contracts: "erc721burnable"
                    },
                    abis: [es, ea],
                    features: {}
                },
                ao = {
                    name: "ERC721Revealable",
                    namespace: "nft.drop.revealer",
                    docLinks: {
                        sdk: "sdk.delayedreveal",
                        contracts: "erc721revealable"
                    },
                    abis: [es, el, ei],
                    features: {}
                },
                ac = {
                    name: "ERC721TieredDrop",
                    namespace: "nft.tieredDrop",
                    docLinks: {
                        sdk: "sdk.erc721tiereddrop",
                        contracts: ""
                    },
                    abis: [es, eb],
                    features: {}
                },
                ad = {
                    name: "ERC721ClaimConditionsV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [es, q],
                    features: {}
                },
                al = {
                    name: "ERC721ClaimConditionsV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [es, J],
                    features: {}
                },
                au = {
                    name: "ERC721ClaimPhasesV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [ef],
                    features: {}
                },
                am = {
                    name: "ERC721ClaimPhasesV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [es, K],
                    features: {}
                },
                ap = {
                    name: "ERC721ClaimCustom",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimcustom"
                    },
                    abis: [es, er],
                    features: {}
                },
                ab = {
                    name: "ERC721ClaimZora",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimzora"
                    },
                    abis: [es, eh],
                    features: {}
                },
                ag = {
                    name: "ERC721LazyMintable",
                    namespace: "nft.drop",
                    docLinks: {
                        sdk: "sdk.erc721lazymintable",
                        contracts: "lazymint"
                    },
                    abis: [es, el],
                    features: {
                        [ao.name]: ao
                    }
                },
                ah = {
                    name: "ERC721BatchMintable",
                    namespace: "nft.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc721batchmintable",
                        contracts: "erc721batchmintable"
                    },
                    abis: [es, eu, ee],
                    features: {}
                },
                ay = {
                    name: "ERC721Mintable",
                    namespace: "nft.mint",
                    docLinks: {
                        sdk: "sdk.erc721mintable",
                        contracts: "erc721mintable"
                    },
                    abis: [es, eu],
                    features: {
                        [ah.name]: ah
                    }
                },
                aw = {
                    name: "ERC721SignatureMintV2",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [es, em],
                    features: {}
                },
                aE = {
                    name: "ERC721SignatureMintV1",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [ep],
                    features: {}
                },
                ak = {
                    name: "ERC721Enumerable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "sdk.erc721enumerable",
                        contracts: "erc721enumerable"
                    },
                    abis: [es, eo],
                    features: {}
                },
                aA = {
                    name: "ERC721AQueryable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ec],
                    features: {}
                },
                aC = {
                    name: "ERC721Supply",
                    namespace: "nft.query",
                    docLinks: {
                        sdk: "sdk.erc721supply",
                        contracts: "erc721supply"
                    },
                    abis: [es, ed],
                    features: {
                        [ak.name]: ak,
                        [aA.name]: aA
                    }
                },
                av = {
                    name: "ERC721SharedMetadata",
                    namespace: "nft.sharedmetadata",
                    docLinks: {
                        sdk: "sdk.sharedmetadata",
                        contracts: "SharedMetadata"
                    },
                    abis: [es, eg],
                    features: {}
                },
                az = {
                    name: "ERC721LoyaltyCard",
                    namespace: "nft.loyaltyCard",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ey],
                    features: {}
                },
                aF = {
                    name: "ERC721UpdatableMetadata",
                    namespace: "nft.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [es, ew],
                    features: {}
                },
                ax = {
                    name: "ERC721",
                    namespace: "nft",
                    docLinks: {
                        sdk: "sdk.erc721",
                        contracts: "erc721"
                    },
                    abis: [es, eE],
                    features: {
                        [as.name]: as,
                        [aC.name]: aC,
                        [ay.name]: ay,
                        [ag.name]: ag,
                        [aE.name]: aE,
                        [aw.name]: aw,
                        [ac.name]: ac,
                        [ap.name]: ap,
                        [ab.name]: ab,
                        [ad.name]: ad,
                        [al.name]: al,
                        [au.name]: au,
                        [am.name]: am,
                        [av.name]: av,
                        [az.name]: az,
                        [aF.name]: aF
                    }
                },
                aT = {
                    name: "ERC1155Burnable",
                    namespace: "edition.burn",
                    docLinks: {
                        sdk: "sdk.erc1155burnable",
                        contracts: "erc1155burnable"
                    },
                    abis: [ex, ek],
                    features: {}
                },
                aS = {
                    name: "ERC1155ClaimConditionsV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155dropsinglephase"
                    },
                    abis: [ex, eF],
                    features: {}
                },
                aP = {
                    name: "ERC1155ClaimConditionsV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimconditions"
                    },
                    abis: [ex, ez],
                    features: {}
                },
                aB = {
                    name: "ERC1155ClaimPhasesV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [ex, eC],
                    features: {}
                },
                aR = {
                    name: "ERC1155ClaimPhasesV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [ev],
                    features: {}
                },
                aO = {
                    name: "ERC1155ClaimCustom",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimcustom"
                    },
                    abis: [ex, eA],
                    features: {}
                },
                aD = {
                    name: "ERC1155Revealable",
                    namespace: "edition.drop.revealer",
                    docLinks: {
                        sdk: "sdk.drop.delayedreveal",
                        contracts: "erc1155revealable"
                    },
                    abis: [ex, el, ei],
                    features: {}
                },
                a$ = {
                    name: "ERC1155LazyMintableV2",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [ex, el],
                    features: {
                        [aD.name]: aD
                    }
                },
                aI = {
                    name: "ERC1155LazyMintableV1",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [ev],
                    features: {
                        [aR.name]: aR
                    }
                },
                aL = {
                    name: "ERC1155SignatureMintable",
                    namespace: "edition.signature",
                    docLinks: {
                        sdk: "sdk.erc1155signaturemintable",
                        contracts: "erc1155signaturemint"
                    },
                    abis: [ex, eR],
                    features: {}
                },
                aN = {
                    name: "ERC1155BatchMintable",
                    namespace: "edition.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc1155batchmintable",
                        contracts: "erc1155batchmintable"
                    },
                    abis: [ex, eB, ee],
                    features: {}
                },
                aM = {
                    name: "ERC1155Mintable",
                    namespace: "edition.mint",
                    docLinks: {
                        sdk: "sdk.erc1155mintable",
                        contracts: "erc1155mintable"
                    },
                    abis: [ex, eB],
                    features: {
                        [aN.name]: aN
                    }
                },
                a_ = {
                    name: "ERC1155Enumerable",
                    namespace: "edition.query",
                    docLinks: {
                        sdk: "sdk.erc1155",
                        contracts: "erc1155enumerable"
                    },
                    abis: [ex, eP],
                    features: {}
                },
                aj = {
                    name: "ERC1155UpdatableMetadata",
                    namespace: "edition.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ex, ew],
                    features: {}
                },
                aU = {
                    name: "ERC1155Supply",
                    namespace: "edition.supply",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ex, eS],
                    features: {}
                },
                aW = {
                    name: "ERC1155",
                    namespace: "edition",
                    docLinks: {
                        sdk: "sdk.erc1155enumerable",
                        contracts: "erc1155"
                    },
                    abis: [ex, eT, [{
                        inputs: [],
                        name: "name",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }, {
                        inputs: [],
                        name: "symbol",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }]],
                    features: {
                        [aU.name]: aU,
                        [aT.name]: aT,
                        [a_.name]: a_,
                        [aM.name]: aM,
                        [aI.name]: aI,
                        [a$.name]: a$,
                        [aD.name]: aD,
                        [aL.name]: aL,
                        [aO.name]: aO,
                        [aS.name]: aS,
                        [aP.name]: aP,
                        [aB.name]: aB,
                        [aj.name]: aj
                    }
                },
                aG = [{
                    inputs: [],
                    name: "getAllPlugins",
                    outputs: [{
                        components: [{
                            internalType: "bytes4",
                            name: "functionSelector",
                            type: "bytes4"
                        }, {
                            internalType: "string",
                            name: "functionSignature",
                            type: "string"
                        }, {
                            internalType: "address",
                            name: "pluginAddress",
                            type: "address"
                        }],
                        internalType: "struct IPluginMap.Plugin[]",
                        name: "registered",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                aH = [{
                    inputs: [],
                    name: "getAllExtensions",
                    outputs: [{
                        components: [{
                            components: [{
                                internalType: "string",
                                name: "name",
                                type: "string"
                            }, {
                                internalType: "string",
                                name: "metadataURI",
                                type: "string"
                            }, {
                                internalType: "address",
                                name: "implementation",
                                type: "address"
                            }],
                            internalType: "struct IExtension.ExtensionMetadata",
                            name: "metadata",
                            type: "tuple"
                        }, {
                            components: [{
                                internalType: "bytes4",
                                name: "functionSelector",
                                type: "bytes4"
                            }, {
                                internalType: "string",
                                name: "functionSignature",
                                type: "string"
                            }],
                            internalType: "struct IExtension.ExtensionFunction[]",
                            name: "functions",
                            type: "tuple[]"
                        }],
                        internalType: "struct IExtension.Extension[]",
                        name: "allExtensions",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                aV = {
                    name: "Royalty",
                    namespace: "royalty",
                    docLinks: {
                        sdk: "sdk.contractroyalty",
                        contracts: "royalty"
                    },
                    abis: [eG],
                    features: {}
                },
                aK = {
                    name: "PrimarySale",
                    namespace: "sales",
                    docLinks: {
                        sdk: "sdk.contractprimarysale",
                        contracts: "primarysale"
                    },
                    abis: [eW],
                    features: {}
                },
                aZ = {
                    name: "PlatformFee",
                    namespace: "platformFees",
                    docLinks: {
                        sdk: "sdk.platformfee",
                        contracts: "platformfee"
                    },
                    abis: [eU],
                    features: {}
                },
                aJ = {
                    name: "PermissionsEnumerable",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissionsenumerable"
                    },
                    abis: [ej],
                    features: {}
                },
                aq = {
                    name: "Permissions",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissions"
                    },
                    abis: [e_],
                    features: {
                        [aJ.name]: aJ
                    }
                },
                aY = {
                    name: "ContractMetadata",
                    namespace: "metadata",
                    docLinks: {
                        sdk: "sdk.contractmetadata",
                        contracts: "contractmetadata"
                    },
                    abis: [e$],
                    features: {}
                },
                aX = {
                    name: "AppURI",
                    namespace: "appURI",
                    docLinks: {
                        sdk: "sdk.appURI",
                        contracts: ""
                    },
                    abis: [eD],
                    features: {}
                },
                aQ = {
                    name: "Ownable",
                    namespace: "owner",
                    docLinks: {
                        sdk: "sdk.owner",
                        contracts: "ownable"
                    },
                    abis: [eH],
                    features: {}
                },
                a0 = {
                    name: "Gasless",
                    namespace: "gasless",
                    docLinks: {
                        sdk: "sdk.gaslesstransaction",
                        contracts: "IERC2771Context"
                    },
                    abis: [eO],
                    features: {}
                },
                a1 = {
                    name: "PackVRF",
                    namespace: "pack.vrf",
                    docLinks: {
                        sdk: "sdk.packvrf",
                        contracts: "IPackVRF"
                    },
                    abis: [eM],
                    features: {}
                },
                a6 = {
                    name: "PluginRouter",
                    namespace: "plugin.router",
                    docLinks: {
                        sdk: "sdk.pluginrouter",
                        contracts: "PluginRouter"
                    },
                    abis: [aG],
                    features: {}
                },
                a5 = {
                    name: "DynamicContract",
                    namespace: "dynamic.contract",
                    docLinks: {
                        sdk: "",
                        contracts: "IExtensionsManager"
                    },
                    abis: [aH],
                    features: {}
                },
                a2 = {
                    name: "DirectListings",
                    namespace: "direct.listings",
                    docLinks: {
                        sdk: "",
                        contracts: "IDirectListings"
                    },
                    abis: [eI],
                    features: {}
                },
                a8 = {
                    name: "EnglishAuctions",
                    namespace: "english.auctions",
                    docLinks: {
                        sdk: "",
                        contracts: "IEnglishAuctions"
                    },
                    abis: [eL],
                    features: {}
                },
                a3 = {
                    name: "Offers",
                    namespace: "offers",
                    docLinks: {
                        sdk: "",
                        contracts: "IOffers"
                    },
                    abis: [eN],
                    features: {}
                },
                a4 = {
                    name: "AccountFactory",
                    namespace: "accountFactory",
                    docLinks: {
                        sdk: "sdk.accountFactory",
                        contracts: "IAccountFactory"
                    },
                    abis: [eJ],
                    features: {}
                },
                a9 = {
                    name: "AccountPermissionsV1",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [eY],
                    features: {}
                },
                a7 = {
                    name: "AccountPermissions",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [eq],
                    features: {}
                },
                re = {
                    name: "Account",
                    namespace: "account",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccount"
                    },
                    abis: [eX],
                    features: {
                        [a7.name]: a7,
                        [a9.name]: a9
                    }
                },
                rt = {
                    name: "AirdropERC20",
                    namespace: "airdrop20",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC20"
                    },
                    abis: [eV],
                    features: {}
                },
                rn = {
                    name: "AirdropERC721",
                    namespace: "airdrop721",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC721"
                    },
                    abis: [eK],
                    features: {}
                },
                ra = {
                    name: "AirdropERC1155",
                    namespace: "airdrop1155",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC1155"
                    },
                    abis: [eZ],
                    features: {}
                },
                rr = {
                    name: "Fallback",
                    namespace: "fallback",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [
                        [{
                            stateMutability: "payable",
                            type: "fallback"
                        }]
                    ],
                    features: {}
                },
                ri = {
                    [af.name]: af,
                    [ax.name]: ax,
                    [aW.name]: aW,
                    [aV.name]: aV,
                    [aZ.name]: aZ,
                    [aK.name]: aK,
                    [aq.name]: aq,
                    [aY.name]: aY,
                    [aX.name]: aX,
                    [aQ.name]: aQ,
                    [a0.name]: a0,
                    [a1.name]: a1,
                    [a6.name]: a6,
                    [a5.name]: a5,
                    [a2.name]: a2,
                    [a8.name]: a8,
                    [a3.name]: a3,
                    [rt.name]: rt,
                    [rn.name]: rn,
                    [ra.name]: ra,
                    [a4.name]: a4,
                    [re.name]: re,
                    [az.name]: az,
                    [aF.name]: aF,
                    [rr.name]: rr
                };

            function rf(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    a = e.type,
                    r = !1;
                return a.endsWith("[]") && (r = !0, a = a.slice(0, -2)), a.startsWith("bytes") && (a = "BytesLike"), (a.startsWith("uint") || a.startsWith("int")) && (a = t ? "BigNumber" : "BigNumberish"), a.startsWith("bool") && (a = "boolean"), "address" === a && (a = "string"), "tuple" === a && e.components && (a = `{ ${e.components.map(e=>rf(e,!1,!0)).join(", ")} }`), r && (a += "[]"), n && (a = `${e.name}: ${a}`), a
            }

            function rs(e, t, n) {
                return t ? .output ? .userdoc ? .[n] ? .[Object.keys(t ? .output ? .userdoc[n] || {}).find(t => t.includes(e || "unknown")) || ""] ? .notice || t ? .output ? .devdoc ? .[n] ? .[Object.keys(t ? .output ? .devdoc[n] || {}).find(t => t.includes(e || "unknown")) || ""] ? .details
            }

            function ro(e, t) {
                let n = (e || []).filter(e => "function" === e.type),
                    a = [];
                for (let e of n) {
                    let n = rs(e.name, t, "methods"),
                        r = e.inputs ? .map(e => `${e.name||"key"}: ${rf(e)}`) ? .join(", ") || "",
                        i = r ? `, [${r}]` : "",
                        f = e.outputs ? .map(e => rf(e, !0)) ? .join(", "),
                        s = f ? `: Promise<${f}>` : ": Promise<TransactionResult>",
                        o = `contract.call("${e.name}"${i})${s}`;
                    a.push({
                        inputs: e.inputs || [],
                        outputs: e.outputs || [],
                        name: e.name || "unknown",
                        signature: o,
                        stateMutability: e.stateMutability || "",
                        comment: n
                    })
                }
                return a
            }

            function rc(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ri,
                    n = {};
                for (let a in t) {
                    let r = t[a],
                        i = function(e, t) {
                            let n = ro(e),
                                a = t.flatMap(e => ro(e));
                            return n.filter(e => void 0 !== a.find(t => t.name === e.name && t.inputs.length === e.inputs.length && t.inputs.every((t, n) => "tuple" === t.type || "tuple[]" === t.type ? t.type === e.inputs[n].type && t.components ? .every((t, a) => t.type === e.inputs[n].components ? .[a] ? .type) : t.type === e.inputs[n].type))).length === a.length
                        }(e, r.abis),
                        f = rc(e, r.features);
                    n[a] = { ...r,
                        features: f,
                        enabled: i
                    }
                }
                return n
            }

            function rd(e, t) {
                if (e)
                    for (let n in e) {
                        let a = e[n];
                        a.enabled && t.push(a), rd(a.features, t)
                    }
            }
            let rl = {};

            function ru(e, t) {
                return rl[`${e}-${t}`]
            }
            async function rm(e, t, n) {
                let a, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                    i = (await t.getNetwork()).chainId,
                    f = ru(e, i);
                if (f) return f;
                if (!(31337 === i || 1337 === i)) try {
                    let t = await fetch(`https://contract.thirdweb.com/metadata/${i}/${e}`);
                    if (t.ok) {
                        let e = await t.json();
                        a = nr(e)
                    }
                } catch (e) {}
                if (a || (a = await rp(e, i, t, n, r)), !a) throw Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${i}/${e}`);
                if (!a.isPartialAbi) {
                    var s;
                    s = a, rl[`${e}-${i}`] = s
                }
                return a
            }
            async function rp(e, t, n, a) {
                let r, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
                    [f, s] = await Promise.all([nY(e, n).catch(() => void 0), rb(e, t, i).then(e => {
                        if (e) return {
                            uri: e,
                            bytecode: ""
                        }
                    }).catch(() => void 0)]),
                    o = f ? .bytecode,
                    c = s ? .uri || f ? .uri;
                if (!c && !o) throw Error(`Could not fetch bytecode for contract at ${e} on chain ${t}, double check that the address and chainId are correct.`);
                try {
                    r = await na(c, a)
                } catch (e) {}
                if (!r && o) {
                    let n;
                    let a = ((n = function(e) {
                        let t = [];
                        return rd(function e(t) {
                            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ri,
                                a = {};
                            for (let r in n) {
                                let i = n[r],
                                    f = function(e, t) {
                                        let n = t.map(e => new eQ.Interface(e)).flatMap(e => Object.values(e.functions).map(t => Number(e.getSighash(t)).toString(16)));
                                        return [...new Set(n)].every(t => e.includes(t))
                                    }(t, i.abis),
                                    s = e(t, i.features);
                                a[r] = { ...i,
                                    features: s,
                                    enabled: f
                                }
                            }
                            return a
                        }(e), t), t
                    }(o)).find(e => "ERC721" === e.name) && (n = n.filter(e => "ERC20" !== e.name)), n3(n.map(e => n3(e.abis))));
                    a && a.length > 0 && (console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${t}/${e}`), r = {
                        name: "Unimported Contract",
                        abi: a,
                        metadata: {},
                        info: {},
                        licenses: [],
                        isPartialAbi: !0
                    })
                }
                return r
            }
            async function rb(e, t, a) {
                let r = (await Promise.resolve().then(n.t.bind(n, 30707, 19))).default;
                if (!p) {
                    let e = a ? .supportedChains ? .find(e => 137 === e.chainId) || M.mgq;
                    p = new F.CH(n5(), r, tn(e, a))
                }
                return await p.getMetadataUri(t, e)
            }
            async function rg(e, t, n) {
                try {
                    let a = await rm(e, t, n);
                    if (a && a.abi) return a.abi
                } catch (e) {}
            }
            async function rh(e, t) {
                let {
                    extendedMetadata: n
                } = await no(e, t);
                return n ? .compositeAbi || []
            }
            let ry = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"],
                rw = [
                    ["account", "not found"],
                    ["wrong", "chainid"]
                ],
                rE = {
                    5001: {
                        name: "Mantle Testnet",
                        gasPrice: 1
                    },
                    71402: {
                        name: "Godwoken Mainnet",
                        gasPrice: 4e4 * 1e9
                    },
                    1351057110: {
                        name: "Chaos (SKALE Testnet)",
                        gasPrice: 1e5
                    },
                    361: {
                        name: "Theta Mainnet",
                        gasPrice: 4e3 * 1e9
                    },
                    365: {
                        name: "Theta Testnet",
                        gasPrice: 4e3 * 1e9
                    },
                    7700: {
                        name: "Canto",
                        gasPrice: 1e3 * 1e9
                    },
                    7701: {
                        name: "Canto Testnet",
                        gasPrice: 1e3 * 1e9
                    },
                    338: {
                        name: "Cronos Testnet",
                        gasPrice: 2e3 * 1e9
                    },
                    199: {
                        name: "BitTorrent Chain",
                        gasPrice: 3e5 * 1e9
                    },
                    88882: {
                        name: "Spicy Chain",
                        gasPrice: 2500 * 1e9,
                        gasLimit: 2e5
                    },
                    88888: {
                        name: "Chiliz Chain",
                        gasPrice: 2500 * 1e9,
                        gasLimit: 2e5
                    }
                };

            function rk(e) {
                let t = ry.findIndex(t => e.includes(t)),
                    n = rw.findIndex(t => {
                        let n = !0;
                        return t.forEach(t => {
                            n && = e.includes(t)
                        }), n
                    });
                return -1 !== t || -1 !== n
            }
            let rA = {
                    v: 27,
                    r: "0x2222222222222222222222222222222222222222222222222222222222222222",
                    s: "0x2222222222222222222222222222222222222222222222222222222222222222"
                },
                rC = "0x4e59b44847b379578588920cA78FbF26c0B4956C",
                rv = 5e6,
                rz = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033",
                rF = [{
                    inputs: [{
                        components: [{
                            internalType: "address",
                            name: "predictedAddress",
                            type: "address"
                        }, {
                            internalType: "address",
                            name: "to",
                            type: "address"
                        }, {
                            internalType: "bytes",
                            name: "data",
                            type: "bytes"
                        }],
                        internalType: "struct IDeployer.Transaction[]",
                        name: "transactions",
                        type: "tuple[]"
                    }],
                    stateMutability: "payable",
                    type: "constructor"
                }];
            async function rx(e, t) {
                let n = await t.getCode(e);
                return "0x" !== n && "0x0" !== n
            }
            async function rT(e) {
                try {
                    await e.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222")
                } catch (n) {
                    let e = n.toString().toLowerCase(),
                        t = JSON.stringify(n).toLowerCase();
                    if (rk(e) || rk(t)) return !0
                }
                return !1
            }

            function rS(e, t) {
                let n = T.joinSignature(rA),
                    a = function(e, t) {
                        let n = T.arrayify(S.keccak256(P.serialize(e)));
                        return {
                            signer: P.recoverAddress(n, t),
                            transaction: P.serialize(e, t)
                        }
                    }({
                        gasPrice: t.gasPrice ? t.gasPrice : 100 * 1e9,
                        gasLimit: t.gasLimit ? t.gasLimit : 1e5,
                        nonce: 0,
                        data: "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",
                        chainId: e
                    }, n),
                    r = C.getContractAddress({
                        from: a.signer,
                        nonce: 0
                    });
                return { ...a,
                    deployment: r
                }
            }
            async function rP(e) {
                if (await rx(rC, e)) return rC;
                let t = await rT(e),
                    n = (await e.getNetwork()).chainId,
                    a = t ? n : 0;
                return (rE[n] ? rS(a, {
                    gasPrice: rE[n].gasPrice,
                    gasLimit: rE[n].gasLimit
                }) : rS(a, {})).deployment
            }
            let rB = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";

            function rR(e) {
                let t = e.startsWith("0x") ? e : `0x${e}`,
                    n = B.id(t),
                    a = `tw.${n}`;
                return B.id(a)
            }

            function rO(e, t, n) {
                let a = e.startsWith("0x") ? e : `0x${e}`,
                    r = n ? B.id(n) : rR(a);
                return R.pack(["bytes32", "bytes", "bytes"], [r, a, t])
            }

            function rD(e, t, n, a) {
                let r = e.startsWith("0x") ? e : `0x${e}`,
                    i = a ? B.id(a) : rR(r),
                    f = R.pack(["bytes", "bytes"], [r, t]),
                    s = R.pack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", n, i, R.keccak256(["bytes"], [f])]),
                    o = R.keccak256(["bytes"], [s]);
                return `0x${o.slice(26)}`
            }
            let r$ = ((b = {})[b.Mainnet = 1] = "Mainnet", b[b.Goerli = 5] = "Goerli", b[b.Polygon = 137] = "Polygon", b[b.Mumbai = 80001] = "Mumbai", b[b.Localhost = 1337] = "Localhost", b[b.Hardhat = 31337] = "Hardhat", b[b.Fantom = 250] = "Fantom", b[b.FantomTestnet = 4002] = "FantomTestnet", b[b.Avalanche = 43114] = "Avalanche", b[b.AvalancheFujiTestnet = 43113] = "AvalancheFujiTestnet", b[b.Optimism = 10] = "Optimism", b[b.OptimismGoerli = 420] = "OptimismGoerli", b[b.Arbitrum = 42161] = "Arbitrum", b[b.ArbitrumGoerli = 421613] = "ArbitrumGoerli", b[b.BinanceSmartChainMainnet = 56] = "BinanceSmartChainMainnet", b[b.BinanceSmartChainTestnet = 97] = "BinanceSmartChainTestnet", b),
                rI = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
                rL = {
                    [r$.Mainnet]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.Goerli]: {
                        name: "G\xf6rli Ether",
                        symbol: "GOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    11155111: {
                        name: "Sepolia Ether",
                        symbol: "SEP",
                        decimals: 18,
                        wrapped: {
                            address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.Polygon]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [r$.Mumbai]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [r$.Avalanche]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [r$.AvalancheFujiTestnet]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [r$.Fantom]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [r$.FantomTestnet]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [r$.Arbitrum]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.ArbitrumGoerli]: {
                        name: "Arbitrum Goerli Ether",
                        symbol: "AGOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.Optimism]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.OptimismGoerli]: {
                        name: "Goerli Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.BinanceSmartChainMainnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "BNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
                            name: "Wrapped Binance Chain Token",
                            symbol: "WBNB"
                        }
                    },
                    [r$.BinanceSmartChainTestnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "TBNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
                            name: "Wrapped Binance Chain Testnet Token",
                            symbol: "WBNB"
                        }
                    },
                    [r$.Hardhat]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [r$.Localhost]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    84531: {
                        name: "Base Goerli Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    280: {
                        name: "zkSync Era Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    }
                };

            function rN(e) {
                let t = nc.find(t => t.chainId === e);
                return t && t.nativeCurrency ? {
                    name: t.nativeCurrency.name,
                    symbol: t.nativeCurrency.symbol,
                    decimals: 18,
                    wrapped: {
                        address: z.d,
                        name: `Wrapped ${t.nativeCurrency.name}`,
                        symbol: `W${t.nativeCurrency.symbol}`
                    }
                } : rL[e] || {
                    name: "Ether",
                    symbol: "ETH",
                    decimals: 18,
                    wrapped: {
                        address: z.d,
                        name: "Wrapped Ether",
                        symbol: "WETH"
                    }
                }
            }
            let rM = {
                [r$.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
                [r$.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                [r$.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
                [r$.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
                [r$.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                [r$.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
                [r$.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
                [r$.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
                [r$.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
            };

            function r_(e) {
                for (let t of tJ.parse(e || []))
                    if ("constructor" === t.type) return t.inputs || [];
                return []
            }
            let rj = {
                    deploymentPresets: {}
                },
                rU = {
                    [r$.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
                    [r$.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [r$.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [r$.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
                    [r$.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
                    [r$.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [r$.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [r$.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
                },
                rW = "0x0000000000000000000000000000000000000000";
            async function rG(e, t, n, a, r, i, f) {
                let s = r && r.contractName,
                    o = r && r.version,
                    c = r && r.publisherAddress,
                    d = r && r.metadata;
                if ((0, j.Z)(s || d, "Require contract name or metadata"), s && rj.deploymentPresets[s]) return rj.deploymentPresets[s];
                if ("WETH9" === s) {
                    let n = rD(rB, [], a),
                        r = await rx(n, t),
                        i = "";
                    return r || (i = rO(rB, [])), {
                        name: s,
                        type: e,
                        transaction: {
                            predictedAddress: n,
                            to: a,
                            data: i
                        }
                    }
                }
                if (!d) {
                    (0, j.Z)(s, "Require contract name"), c || (c = nl);
                    let e = await nu(c, s, o, n, i, f);
                    d = (await no(e.metadataUri, n)).compilerMetadata
                }
                let l = await rH(d, t, n, a, r ? .constructorParams, i, f),
                    u = rD(d.bytecode, l, a),
                    m = await rx(u, t),
                    p = "";
                return m || (p = rO(d.bytecode, l)), {
                    name: s,
                    type: e,
                    transaction: {
                        predictedAddress: u,
                        to: a,
                        data: p
                    },
                    encodedArgs: l
                }
            }
            async function rH(e, t, n, a, r, i, f) {
                let s = r_(e.abi),
                    o = s.map(e => "tuple[]" === e.type || "tuple" === e.type ? O._R.from(e) : e.type),
                    c = await Promise.all(s.map(async s => {
                        if (r && r[s.name]) return r[s.name].type && (0, j.Z)(r[s.name].type === s.type, `Provided type ${r[s.name].type} doesn't match the actual type ${s.type} from Abi`), r[s.name].value;
                        if (s.name && s.name.includes("nativeTokenWrapper")) return await rV(t, n, a, i, f);
                        if (s.name && s.name.includes("trustedForwarder")) {
                            if ("Pack" === e.name) return rW;
                            let r = await rG("infra", t, n, a, {
                                contractName: "Forwarder"
                            }, i, f);
                            return rj.deploymentPresets.Forwarder || (rj.deploymentPresets.Forwarder = r), r.transaction.predictedAddress
                        }
                        if (s.name && s.name.includes("royaltyEngineAddress")) return rU[(await t.getNetwork()).chainId] || z.d;
                        if (s.name && s.name.includes("marketplaceV3Params")) {
                            let e = rU[(await t.getNetwork()).chainId] || z.d,
                                s = await rV(t, n, a, i, f);
                            return {
                                extensions: r ? r._extensions.value : [],
                                royaltyEngineAddress: e,
                                nativeTokenWrapper: s
                            }
                        }
                        throw Error("Can't resolve constructor arguments")
                    }));
                return D.$.encode(o, c)
            }
            async function rV(e, t, n, a, r) {
                let i = rN((await e.getNetwork()).chainId).wrapped.address;
                if (i === z.d) {
                    let f = await rG("infra", e, t, n, {
                        contractName: "WETH9"
                    }, a, r);
                    rj.deploymentPresets.WETH9 || (rj.deploymentPresets.WETH9 = f), i = f.transaction.predictedAddress
                }
                return i
            }
            async function rK(e, t, n, a, r) {
                return n && "" !== n || (n = await rP(e)), (await rG("infra", e, t, n, {
                    contractName: "ForwarderEOAOnly"
                }, a, r)).transaction.predictedAddress
            }
            async function rZ(e, t, n, a, r) {
                return n && "" !== n || (n = await rP(e)), (await rG("infra", e, t, n, {
                    contractName: "Forwarder"
                }, a, r)).transaction.predictedAddress
            }
            class rJ extends Error {
                constructor(e) {
                    super(e ? `Object with id ${e} NOT FOUND` : "NOT_FOUND")
                }
            }
            class rq extends Error {
                constructor(e, t) {
                    super(`MISSING ROLE: ${e} does not have the '${t}' role`)
                }
            }
            class rY extends Error {
                constructor(e) {
                    super(`DUPLICATE_LEAFS${e?` : ${e}`:""}`)
                }
            }
            class rX extends Error {
                constructor(e) {
                    super(`Auction already started with existing bid${e?`, id: ${e}`:""}`)
                }
            }
            class rQ extends Error {
                constructor(e, t) {
                    super(`Could not find listing.${e?` marketplace address: ${e}`:""}${t?` listing id: ${t}`:""}`)
                }
            }
            class r0 extends Error {
                constructor(e, t, n, a) {
                    super(`Incorrect listing type. Are you sure you're using the right method?.${e?` marketplace address: ${e}`:""}${t?` listing id: ${t}`:""}${a?` expected type: ${a}`:""}${n?` actual type: ${n}`:""}`)
                }
            }
            class r1 extends Error {
                constructor(e, t) {
                    super(`Auction has not ended yet${e?`, id: ${e}`:""}${t?`, end time: ${t.toString()}`:""}`)
                }
            }
            class r6 extends Error {
                constructor(e) {
                    super(`This functionality is not available because the contract does not implement the '${e.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/contracts/build/extensions `)
                }
            }
            class r5 extends Error {#
                e;#
                t;#
                n;
                constructor(e, t) {
                    let n = `



 TRANSACTION ERROR 


`;
                    if (n += `Reason: ${e.reason}



 TRANSACTION INFORMATION 

` + r8("from", e.from), e.to && (n += r8("to", e.contractName ? `${e.to} (${e.contractName})` : e.to)), n += r8("chain", `${e.network.name} (${e.network.chainId})`), e.rpcUrl) try {
                        let t = new URL(e.rpcUrl);
                        n += r8("rpc", t.hostname)
                    } catch (e) {}
                    if (e.hash && (n += r8("tx hash", e.hash)), e.value && e.value.gt(0) && (n += r8("value", `${$.formatEther(e.value)} ${rL[e.network.chainId]?.symbol||""}`)), n += r8("data", `${e.data}`), e.method && (n += r8("method", e.method)), e.sources) {
                        let t = e.sources.find(t => t.source.includes(e.reason));
                        if (t) {
                            let a = t.source.split("\n").map((e, t) => `${t+1}  ${e}`),
                                r = a.findIndex(t => t.includes(e.reason));
                            a[r] += "   <-- REVERT";
                            let i = a.slice(r - 8, r + 4);
                            n += `



 SOLIDITY STACK TRACE 


File: ${t.filename.replace("node_modules/","")}

` + i.join("\n")
                        }
                    }
                    super(n += `



 DEBUGGING RESOURCES 


Need helping debugging? Join our Discord: https://discord.gg/thirdweb

`), this.#e = e.reason, this.#t = e, this.#n = t
                }
                get reason() {
                    return this.#e
                }
                get raw() {
                    return this.#n
                }
                get info() {
                    return this.#t
                }
            }

            function r2(e) {
                if (e.reason && !e.reason.includes("cannot estimate gas")) return e.reason;
                if (e.error) return e.error;
                let t = e;
                return "object" == typeof e ? t = JSON.stringify(e) : "string" != typeof e && (t = e.toString()), r3(/.*?"message":"([^"\\]*).*?/, t) || r3(/.*?"reason":"([^"\\]*).*?/, t) || e.message || ""
            }

            function r8(e, t) {
                if ("" === t) return t;
                let n = Array(10 - e.length).fill(" ").join("");
                return t = t.includes("\n") ? "\n\n  " + t.split("\n").join(`
  `) : `${n}${t}`, `
${e}:${t}`
            }

            function r3(e, t) {
                let n = t.match(e) || [],
                    a = "";
                return n ? .length > 0 && (a += n[1]), a
            }

            function r4(e, t) {
                return !!e && (e && e.toString().includes(t) || e && e.message && e.message.toString().includes(t) || e && e.error && e.error.toString().includes(t))
            }
            async function r9(e, t) {
                return await Promise.all(Object.entries(e.metadata.sources).map(async e => {
                    let [n, a] = e, r = a.urls, i = r ? r.find(e => e.includes("ipfs")) : void 0;
                    if (!i) return {
                        filename: n,
                        source: a.content || "Could not find source for this contract"
                    }; {
                        let e = i.split("ipfs/")[1],
                            a = new Promise((e, t) => setTimeout(() => t("timeout"), 3e3));
                        return {
                            filename: n,
                            source: await Promise.race([(await t.download(`ipfs://${e}`)).text(), a])
                        }
                    }
                }))
            }
            let r7 = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }],
                ie = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }, {
                    name: "chainid",
                    type: "uint256"
                }],
                it = [{
                    inputs: [{
                        internalType: "address",
                        name: "from",
                        type: "address"
                    }, {
                        internalType: "uint256",
                        name: "batchId",
                        type: "uint256"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ia = {},
                ir = {};
            async function ii(e, t, n) {
                let a = n.join("|"),
                    r = ir[a],
                    i = Date.now() - r >= 2e3;
                if (!(a in ia) || i) {
                    let r = await e.functions[t](...n);
                    Array.isArray(r) && r.length > 0 ? ia[a] = v.O$.from(r[0]) : ia[a] = v.O$.from(r), ir[a] = Date.now()
                }
                let f = ia[a];
                return ia[a] = v.O$.from(ia[a]).add(1), f
            }
            async function is(e) {
                if (n2()) return {};
                e.originalProvider && (e = e.originalProvider);
                let t = await io(e);
                return t.maxFeePerGas && t.maxPriorityFeePerGas ? {
                    maxFeePerGas: t.maxFeePerGas,
                    maxPriorityFeePerGas: t.maxPriorityFeePerGas
                } : {
                    gasPrice: await ic(e)
                }
            }
            async function io(e) {
                let t = null,
                    [{
                        chainId: n
                    }, a, r] = await Promise.all([e.getNetwork(), e.getBlock("latest"), e.send("eth_maxPriorityFeePerGas", []).catch(() => null)]),
                    i = a && a.baseFeePerGas ? a.baseFeePerGas : $.parseUnits("100", "wei");
                if (n === M.Nj4.chainId || n === M.mgq.chainId) t = await iu(n);
                else if (r) t = v.O$.from(r);
                else if (!(t = (await e.getFeeData()).maxPriorityFeePerGas)) return {
                    maxFeePerGas: null,
                    maxPriorityFeePerGas: null,
                    baseFee: null
                };
                return t = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
                        n = e.div(100).mul(t);
                    return e.add(n)
                }(t), {
                    maxFeePerGas: i.mul(2).add(t),
                    maxPriorityFeePerGas: t,
                    baseFee: i
                }
            }
            async function ic(e) {
                let t = await e.getGasPrice(),
                    n = $.parseUnits("300", "gwei"),
                    a = t.div(100).mul(10),
                    r = t.add(a);
                return r.gt(n) ? n : r
            }
            let id = $.parseUnits("31", "gwei"),
                il = $.parseUnits("1", "gwei");
            async function iu(e) {
                let t = function(e) {
                    switch (e) {
                        case r$.Polygon:
                            return "https://gasstation.polygon.technology/v2";
                        case r$.Mumbai:
                            return "https://gasstation-testnet.polygon.technology/v2"
                    }
                }(e);
                try {
                    let e = (await (await fetch(t)).json()).fast.maxPriorityFee;
                    if (e > 0) {
                        let t = parseFloat(e).toFixed(9);
                        return $.parseUnits(t, "gwei")
                    }
                } catch (e) {
                    console.error("failed to fetch gas", e)
                }
                return function(e) {
                    switch (e) {
                        case r$.Polygon:
                            return id;
                        case r$.Mumbai:
                            return il
                    }
                }(e)
            }
            async function im(e, t, n, a) {
                let r = e;
                e.originalSigner && (r = e.originalSigner);
                let i = r ? .provider;
                if (!i) throw Error("missing provider");
                let f = I.E.getPayload(t, n, a),
                    s = "",
                    o = (await r.getAddress()).toLowerCase();
                if (i ? .provider ? .isWalletConnect) s = await i.send("eth_signTypedData", [o, JSON.stringify(f)]);
                else try {
                    s = await r._signTypedData(t, n, a)
                } catch (e) {
                    if (e ? .message ? .includes("eth_signTypedData_v4")) s = await i.send("eth_signTypedData", [o, JSON.stringify(f)]);
                    else try {
                        await i.send("eth_signTypedData_v4", [o, JSON.stringify(f)])
                    } catch (e) {
                        throw e
                    }
                }
                return {
                    payload: f,
                    signature: T.joinSignature(T.splitSignature(s))
                }
            }
            let ip = [{
                    inputs: [],
                    name: "name",
                    outputs: [{
                        internalType: "string",
                        name: "",
                        type: "string"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ib = [{
                    constant: !0,
                    inputs: [],
                    name: "DOMAIN_SEPARATOR",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    payable: !1,
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [],
                    name: "getDomainSeperator",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ig = [{
                    inputs: [{
                        internalType: "address",
                        name: "owner",
                        type: "address"
                    }],
                    name: "nonces",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [{
                        internalType: "address",
                        name: "user",
                        type: "address"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }];
            async function ih(e, t) {
                let n = new F.CH(t, ig, e);
                try {
                    return await n.nonces(await e.getAddress())
                } catch (t) {
                    return await n.getNonce(await e.getAddress())
                }
            }
            async function iy(e, t) {
                let n = new F.CH(t, ib, e);
                try {
                    return await n.DOMAIN_SEPARATOR()
                } catch (e) {
                    try {
                        return await n.getDomainSeperator()
                    } catch (e) {
                        console.error("Error getting domain separator", e)
                    }
                }
            }
            async function iw(e, t) {
                return new F.CH(t, ip, e).name()
            }
            async function iE(e, t) {
                let n = await iy(e, t.verifyingContract),
                    a = {
                        name: t.name,
                        version: t.version,
                        verifyingContract: t.verifyingContract,
                        salt: T.hexZeroPad(v.O$.from(t.chainId).toHexString(), 32)
                    };
                return I.E.hashDomain(a) === n ? a : t
            }
            async function ik(e, t, n, a, r, i, f) {
                let [s, o, c] = await Promise.all([iw(e, t), e.getChainId(), ih(e, t)]), d = await iE(e, {
                    name: s,
                    version: "1",
                    chainId: o,
                    verifyingContract: t
                }), l = {
                    owner: n,
                    spender: a,
                    value: r,
                    nonce: f = f || c.toString(),
                    deadline: i = i || L.Bz
                }, {
                    signature: u
                } = await im(e, d, {
                    Permit: [{
                        name: "owner",
                        type: "address"
                    }, {
                        name: "spender",
                        type: "address"
                    }, {
                        name: "value",
                        type: "uint256"
                    }, {
                        name: "nonce",
                        type: "uint256"
                    }, {
                        name: "deadline",
                        type: "uint256"
                    }]
                }, l);
                return {
                    message: l,
                    signature: u
                }
            }
            let iA = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
                iC = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",
                iv = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",
                iz = {
                    [r$.Mainnet]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
                        biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.Goerli]: {
                        openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
                    },
                    [r$.Polygon]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
                    },
                    [r$.Mumbai]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
                    },
                    [r$.Avalanche]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.AvalancheFujiTestnet]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [r$.Fantom]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.FantomTestnet]: {
                        openzeppelinForwarder: iv,
                        openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
                        biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
                        twFactory: iC,
                        twRegistry: iA,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [r$.Arbitrum]: {
                        openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.ArbitrumGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: rW,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.Optimism]: {
                        openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.OptimismGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: rW,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: iA,
                        twBYOCRegistry: rW
                    },
                    [r$.BinanceSmartChainMainnet]: {
                        openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
                        openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twBYOCRegistry: rW,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: iA
                    },
                    [r$.BinanceSmartChainTestnet]: {
                        openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
                        twBYOCRegistry: rW,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: iA
                    },
                    [r$.Hardhat]: {
                        openzeppelinForwarder: rW,
                        openzeppelinForwarderEOA: rW,
                        biconomyForwarder: rW,
                        twFactory: rW,
                        twRegistry: rW,
                        twBYOCRegistry: rW
                    },
                    [r$.Localhost]: {
                        openzeppelinForwarder: rW,
                        openzeppelinForwarderEOA: rW,
                        biconomyForwarder: rW,
                        twFactory: rW,
                        twRegistry: rW,
                        twBYOCRegistry: rW
                    }
                };

            function iF(e, t) {
                return e === r$.Hardhat || e === r$.Localhost ? "twFactory" === t ? e5("factoryAddress") : "twRegistry" === t ? e5("registryAddress") : rW : iz[e] ? .[t]
            }
            let ix = ((g = {}).Transaction = "transaction", g.Signature = "signature", g),
                iT = N.z.object({
                    gasLimit: tS.optional(),
                    gasPrice: tS.optional(),
                    maxFeePerGas: tS.optional(),
                    maxPriorityFeePerGas: tS.optional(),
                    nonce: tS.optional(),
                    value: tS.optional(),
                    blockTag: N.z.union([N.z.string(), N.z.number()]).optional(),
                    from: tl.optional(),
                    type: N.z.number().optional()
                }).strict();
            class iS extends e0.Z {
                constructor(e, t) {
                    super();
                    try {
                        this.options = te.parse(t)
                    } catch (e) {
                        console.error("invalid sdk options object passed, falling back to default options", e), this.options = te.parse({})
                    }
                    let [n, a] = tf(e, this.options);
                    this.network = e, this.signer = n, this.provider = a
                }
                updateSignerOrProvider(e) {
                    let [t, n] = tf(e, this.options);
                    this.network = e, this.signer = t, this.provider = n
                }
                isReadOnly() {
                    return !e8(this.signer)
                }
                getSigner() {
                    return this.signer
                }
                getProvider() {
                    return this.provider
                }
                getSignerOrProvider() {
                    return this.getSigner() || this.getProvider()
                }
            }
            class iP extends iS {
                isValidContract = !1;
                customOverrides = () => ({});
                constructor(e, t, n, a, r) {
                    super(e, a), this.abi = n, this.address = t, this.writeContract = new F.CH(t, n, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.storage = r
                }
                updateSignerOrProvider(e) {
                    super.updateSignerOrProvider(e), this.writeContract = this.writeContract.connect(this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider())
                }
                updateAbi(e) {
                    this.writeContract = new F.CH(this.address, e, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.abi = tJ.parse(e)
                }
                async getChainID() {
                    let e = this.getProvider(),
                        {
                            chainId: t
                        } = await e.getNetwork();
                    return t
                }
                async getSignerAddress() {
                    let e = this.getSigner();
                    if (!e) throw Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
                    return await e.getAddress()
                }
                callStatic() {
                    return this.writeContract.callStatic
                }
                async getCallOverrides() {
                    return is(this.getProvider())
                }
                emitTransactionEvent(e, t) {
                    this.emit(ix.Transaction, {
                        status: e,
                        transactionHash: t
                    })
                }
                async multiCall(e) {
                    return this.sendTransaction("multicall", [e])
                }
                async estimateGas(e, t) {
                    return this.writeContract.estimateGas[e](...t)
                }
                withTransactionOverride(e) {
                    this.customOverrides = e
                }
                async read(e, t) {
                    let n = ro(tJ.parse(this.abi)).filter(t => t.name === e);
                    if (!n.length) throw Error(`Function "${e.toString()}" not found in contract. Check your dashboard for the list of functions available`);
                    let a = n.find(n => n.name === e && n.inputs.length === t.length);
                    if (!a) throw Error(`Function "${e.toString()}" requires ${n[0].inputs.length} arguments, but ${t.length} were provided.
Expected function signature: ${n[0].signature}`);
                    let r = `${e.toString()}(${a.inputs.map(e=>e.type).join()})`,
                        i = r in this.readContract.functions ? r : e;
                    if ("view" === a.stateMutability || "pure" === a.stateMutability) return await this.readContract[i.toString()](...t);
                    throw Error("Cannot call a write function with read()")
                }
                async call(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        a = n ? await iT.parseAsync(n) : void 0,
                        r = ro(tJ.parse(this.abi)).filter(t => t.name === e);
                    if (!r.length) throw Error(`Function "${e}" not found in contract. Check your dashboard for the list of functions available`);
                    let i = r.find(n => n.name === e && n.inputs.length === t.length);
                    if (!i) throw Error(`Function "${e}" requires ${r[0].inputs.length} arguments, but ${t.length} were provided.
Expected function signature: ${r[0].signature}`);
                    let f = `${e}(${i.inputs.map(e=>e.type).join()})`,
                        s = f in this.readContract.functions ? f : e;
                    return "view" === i.stateMutability || "pure" === i.stateMutability ? a ? this.readContract[s](...t, a) : this.readContract[s](...t) : {
                        receipt: await this.sendTransaction(s, t, a)
                    }
                }
                async sendTransaction(e, t, n) {
                    if (n || (n = await this.getCallOverrides()), n = { ...n,
                            ...this.customOverrides()
                        }, this.customOverrides = () => ({}), this.options ? .gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless || "engine" in this.options.gasless)) {
                        if ("multicall" === e && Array.isArray(t[0]) && t[0].length > 0) {
                            let e = await this.getSignerAddress();
                            t[0] = t[0].map(t => R.pack(["bytes", "address"], [t, e]))
                        }
                        let a = this.getProvider(),
                            r = await this.sendGaslessTransaction(e, t, n);
                        this.emitTransactionEvent("submitted", r);
                        let i = await a.waitForTransaction(r);
                        return this.emitTransactionEvent("completed", r), i
                    } {
                        let a;
                        if (!this.isValidContract) {
                            let e = await this.getProvider().getCode(this.address);
                            if (this.isValidContract = "0x" !== e, !this.isValidContract) throw Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct")
                        }
                        let r = await this.sendTransactionByFunction(e, t, n);
                        this.emitTransactionEvent("submitted", r.hash);
                        try {
                            a = await r.wait()
                        } catch (a) {
                            try {
                                await this.writeContract.callStatic[e](...t, ...n.value ? [{
                                    value: n.value
                                }] : [])
                            } catch (a) {
                                throw await this.formatError(a, e, t, n)
                            }
                            throw await this.formatError(a, e, t, n)
                        }
                        return this.emitTransactionEvent("completed", r.hash), a
                    }
                }
                async sendTransactionByFunction(e, t, n) {
                    let a = this.writeContract.functions[e];
                    if (!a) throw Error(`invalid function: "${e.toString()}"`);
                    if (!n.gasLimit) try {
                        n.gasLimit = await this.writeContract.estimateGas[e](...t, n)
                    } catch (a) {
                        try {
                            await this.writeContract.callStatic[e](...t, ...n.value ? [{
                                value: n.value
                            }] : [])
                        } catch (a) {
                            throw await this.formatError(a, e, t, n)
                        }
                    }
                    try {
                        return await a(...t, n)
                    } catch (a) {
                        throw await this.formatError(a, e, t, n)
                    }
                }
                async formatError(e, t, n, a) {
                    let r, i;
                    let f = this.getProvider(),
                        s = await f.getNetwork(),
                        o = await (a.from || this.getSignerAddress()),
                        c = this.address,
                        d = this.readContract.interface.encodeFunctionData(t, n),
                        l = v.O$.from(a.value || 0),
                        u = f.connection ? .url,
                        m = this.readContract.interface.getFunction(t),
                        p = n.map(e => JSON.stringify(e).length <= 80 ? JSON.stringify(e) : JSON.stringify(e, void 0, 2)),
                        b = p.join(", ").length <= 80 ? p.join(", ") : "\n" + p.map(e => "  " + e.split("\n").join("\n  ")).join(",\n") + "\n",
                        g = `${m.name}(${b})`,
                        h = e.transactionHash || e.transaction ? .hash || e.receipt ? .transactionHash,
                        y = r2(e);
                    try {
                        let e = await rm(this.address, this.getProvider(), this.storage, this.options);
                        e.name && (i = e.name), e.metadata.sources && (r = await r9(e, this.storage))
                    } catch (e) {}
                    return new r5({
                        reason: y,
                        from: o,
                        to: c,
                        method: g,
                        data: d,
                        network: s,
                        rpcUrl: u,
                        value: l,
                        hash: h,
                        contractName: i,
                        sources: r
                    }, e)
                }
                async sendGaslessTransaction(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        a = this.getSigner();
                    (0, j.Z)(a, "Cannot execute gasless transaction without valid signer");
                    let r = await this.getChainID(),
                        i = await this.getSignerAddress(),
                        f = this.writeContract.address,
                        s = n ? .value || 0;
                    if (v.O$.from(s).gt(0)) throw Error("Cannot send native token value with gasless transaction");
                    let o = this.writeContract.interface.encodeFunctionData(e, t),
                        c = v.O$.from(0);
                    try {
                        c = (await this.readContract.estimateGas[e](...t)).mul(2)
                    } catch (e) {}
                    c.lt(1e5) && (c = v.O$.from(5e5)), n.gasLimit && v.O$.from(n.gasLimit).gt(c) && (c = v.O$.from(n.gasLimit));
                    let d = {
                        from: i,
                        to: f,
                        data: o,
                        chainId: r,
                        gasLimit: c,
                        functionName: e.toString(),
                        functionArgs: t,
                        callOverrides: n
                    };
                    return await this.defaultGaslessSendFunction(d)
                }
                async signTypedData(e, t, n, a) {
                    this.emit(ix.Signature, {
                        status: "submitted",
                        message: a,
                        signature: ""
                    });
                    let {
                        signature: r
                    } = await im(e, t, n, a);
                    return this.emit(ix.Signature, {
                        status: "completed",
                        message: a,
                        signature: r
                    }), r
                }
                parseLogs(e, t) {
                    if (!t || 0 === t.length) return [];
                    let n = this.writeContract.interface.getEventTopic(e);
                    return t.filter(e => e.topics.indexOf(n) >= 0).map(e => this.writeContract.interface.parseLog(e))
                }
                async defaultGaslessSendFunction(e) {
                    return this.options.gasless && "biconomy" in this.options.gasless ? this.biconomySendFunction(e) : this.options.gasless && "openzeppelin" in this.options.gasless ? this.defenderSendFunction(e) : this.engineSendFunction(e)
                }
                async engineSendFunction(e) {
                    (0, j.Z)(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without engine config in the SDK options");
                    let t = await this.enginePrepareRequest(e),
                        n = await fetch(this.options.gasless.engine.relayerUrl, { ...t,
                            headers: {
                                "Content-Type": "application/json"
                            }
                        }),
                        a = await n.json();
                    if (a.error) throw Error(a.error ? .message || JSON.stringify(a.error));
                    let r = a.result.queueId,
                        i = this.options.gasless.engine.relayerUrl.split("/relayer/")[0],
                        f = Date.now();
                    for (;;) {
                        let e = await fetch(`${i}/transaction/status/${r}`),
                            t = await e.json();
                        if (t.result.transactionHash) return t.result.transactionHash;
                        if (Date.now() - f > 3e4) throw Error("timeout");
                        await new Promise(e => setTimeout(e, 2e3))
                    }
                }
                async enginePrepareRequest(e) {
                    let t = this.getSigner(),
                        a = this.getProvider(),
                        r = this.storage;
                    (0, j.Z)(t, "signer is not set");
                    try {
                        let {
                            abi: n
                        } = await rm(e.to, a, r), i = (await a.getNetwork()).chainId, f = new iP(t, e.to, n, {}, r);
                        if (n.find(e => "executeMetaTransaction" === e.name)) {
                            let n = {
                                    name: await f.call("name", []),
                                    version: "1",
                                    salt: "0x" + i.toString(16).padStart(64, "0"),
                                    verifyingContract: e.to
                                },
                                a = {
                                    nonce: await f.call("getNonce", [e.from]),
                                    from: e.from,
                                    functionSignature: e.data
                                },
                                {
                                    signature: r
                                } = await im(t, n, {
                                    MetaTransaction: [{
                                        name: "nonce",
                                        type: "uint256"
                                    }, {
                                        name: "from",
                                        type: "address"
                                    }, {
                                        name: "functionSignature",
                                        type: "bytes"
                                    }]
                                }, a);
                            return {
                                method: "POST",
                                body: JSON.stringify({
                                    type: "execute-meta-transaction",
                                    request: {
                                        from: e.from,
                                        to: e.to,
                                        data: e.data
                                    },
                                    signature: r
                                })
                            }
                        }
                    } catch {}
                    if ("approve" === e.functionName && 2 === e.functionArgs.length) {
                        let n = e.functionArgs[0],
                            a = e.functionArgs[1],
                            {
                                message: r,
                                signature: i
                            } = await ik(t, e.to, e.from, n, a);
                        return {
                            method: "POST",
                            body: JSON.stringify({
                                type: "permit",
                                request: {
                                    to: e.to,
                                    owner: r.owner,
                                    spender: r.spender,
                                    value: v.O$.from(r.value).toString(),
                                    nonce: v.O$.from(r.nonce).toString(),
                                    deadline: v.O$.from(r.deadline).toString()
                                },
                                signature: i
                            })
                        }
                    } {
                        let i = iz[e.chainId] ? .openzeppelinForwarder || await rZ(a, r),
                            f = (await n.e(1303).then(n.t.bind(n, 61303, 19))).default,
                            s = new F.CH(i, f, a),
                            o = await ii(s, "getNonce", [e.from]),
                            c = {
                                name: "GSNv2 Forwarder",
                                version: "0.0.1",
                                chainId: e.chainId,
                                verifyingContract: i
                            },
                            d = {
                                from: e.from,
                                to: e.to,
                                value: v.O$.from(0).toString(),
                                gas: v.O$.from(e.gasLimit).toString(),
                                nonce: v.O$.from(o).toString(),
                                data: e.data
                            },
                            {
                                signature: l
                            } = await im(t, c, {
                                ForwardRequest: r7
                            }, d);
                        return {
                            method: "POST",
                            body: JSON.stringify({
                                type: "forward",
                                request: d,
                                signature: l,
                                forwarderAddress: i
                            })
                        }
                    }
                }
                async biconomySendFunction(e) {
                    (0, j.Z)(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
                    let t = this.getSigner(),
                        n = this.getProvider();
                    (0, j.Z)(t && n, "signer and provider must be set");
                    let a = new F.CH(iF(e.chainId, "biconomyForwarder"), it, n),
                        r = await ii(a, "getNonce", [e.from, 0]),
                        i = {
                            from: e.from,
                            to: e.to,
                            token: z.d,
                            txGas: e.gasLimit.toNumber(),
                            tokenGasPrice: "0",
                            batchId: 0,
                            batchNonce: r.toNumber(),
                            deadline: Math.floor(Date.now() / 1e3 + (this.options ? .gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy ? .deadlineSeconds || 3600)),
                            data: e.data
                        },
                        f = T.arrayify(R.keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [i.from, i.to, i.token, i.txGas, i.tokenGasPrice, i.batchId, i.batchNonce, i.deadline, S.keccak256(i.data)]));
                    this.emit(ix.Signature, {
                        status: "submitted",
                        message: f,
                        signature: ""
                    });
                    let s = await t.signMessage(f);
                    this.emit(ix.Signature, {
                        status: "completed",
                        message: f,
                        signature: s
                    });
                    let o = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
                        method: "POST",
                        body: JSON.stringify({
                            from: e.from,
                            apiId: this.options.gasless.biconomy.apiId,
                            params: [i, s],
                            to: e.to,
                            gasLimit: e.gasLimit.toHexString()
                        }),
                        headers: {
                            "x-api-key": this.options.gasless.biconomy.apiKey,
                            "Content-Type": "application/json;charset=utf-8"
                        }
                    });
                    if (o.ok) {
                        let e = await o.json();
                        if (!e.txHash) throw Error(`relay transaction failed: ${e.log}`);
                        return e.txHash
                    }
                    throw Error(`relay transaction failed with status: ${o.status} (${o.statusText})`)
                }
                async defenderSendFunction(e) {
                    let t, a, r, i;
                    (0, j.Z)(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
                    let f = this.getSigner(),
                        s = this.getProvider();
                    (0, j.Z)(f, "provider is not set"), (0, j.Z)(s, "provider is not set");
                    let o = (await n.e(1303).then(n.t.bind(n, 61303, 19))).default,
                        c = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? iz[e.chainId] ? .openzeppelinForwarderEOA || await rK(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey) : iz[e.chainId] ? .openzeppelinForwarder || await rZ(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)),
                        d = new F.CH(c, o, s),
                        l = await ii(d, "getNonce", [e.from]);
                    if (this.options.gasless.experimentalChainlessSupport ? (t = {
                            name: "GSNv2 Forwarder",
                            version: "0.0.1",
                            verifyingContract: c
                        }, a = {
                            ForwardRequest: ie
                        }, r = {
                            from: e.from,
                            to: e.to,
                            value: v.O$.from(0).toString(),
                            gas: v.O$.from(e.gasLimit).toString(),
                            nonce: v.O$.from(l).toString(),
                            data: e.data,
                            chainid: v.O$.from(e.chainId).toString()
                        }) : (t = {
                            name: this.options.gasless.openzeppelin.domainName,
                            version: this.options.gasless.openzeppelin.domainVersion,
                            chainId: e.chainId,
                            verifyingContract: c
                        }, a = {
                            ForwardRequest: r7
                        }, r = {
                            from: e.from,
                            to: e.to,
                            value: v.O$.from(0).toString(),
                            gas: v.O$.from(e.gasLimit).toString(),
                            nonce: v.O$.from(l).toString(),
                            data: e.data
                        }), this.emit(ix.Signature, {
                            status: "submitted",
                            message: r,
                            signature: ""
                        }), "approve" === e.functionName && 2 === e.functionArgs.length) {
                        let t = e.functionArgs[0],
                            n = e.functionArgs[1],
                            {
                                message: a,
                                signature: s
                            } = await ik(f, this.writeContract.address, e.from, t, n),
                            {
                                r: o,
                                s: c,
                                v: d
                            } = T.splitSignature(s);
                        r = {
                            to: this.address,
                            owner: a.owner,
                            spender: a.spender,
                            value: v.O$.from(a.value).toString(),
                            nonce: v.O$.from(a.nonce).toString(),
                            deadline: v.O$.from(a.deadline).toString(),
                            r: o,
                            s: c,
                            v: d
                        }, i = s
                    } else {
                        let {
                            signature: e
                        } = await im(f, t, a, r);
                        i = e
                    }
                    let u = "forward";
                    r ? .owner && (u = "permit");
                    let m = JSON.stringify({
                        request: r,
                        signature: i,
                        forwarderAddress: c,
                        type: u
                    });
                    this.emit(ix.Signature, {
                        status: "completed",
                        message: r,
                        signature: i
                    });
                    let p = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
                        method: "POST",
                        body: m
                    });
                    if (p.ok) {
                        let e = await p.json();
                        if (!e.result) throw Error(`Relay transaction failed: ${e.message}`);
                        return JSON.parse(e.result).txHash
                    }
                    throw Error(`relay transaction failed with status: ${p.status} (${p.statusText})`)
                }
            }

            function iB(e, t) {
                return function e(t, n) {
                    let a = Object.keys(t);
                    if (!a.includes(n)) {
                        let r = !1;
                        for (let i of a)
                            if (r = e(t[i].features, n)) break;
                        return r
                    }
                    return t[n].enabled
                }(rc(e), t)
            }

            function iR(e, t) {
                return iB(e, t)
            }
            async function iO(e, t, n) {
                return (await Promise.all(e.map(e => rm(e, t, n).catch(t => (console.error(`Failed to fetch plug-in for ${e}`, t), {
                    abi: []
                }))))).map(e => e.abi)
            }
            async function iD(e, t, n, a, r) {
                let i = [];
                try {
                    var f, s, o;
                    let c = (f = tJ.parse(t), iB(f, "PluginRouter")),
                        d = (s = tJ.parse(t), iB(s, "DynamicContract")),
                        l = (o = tJ.parse(t), iB(o, "Fallback"));
                    if (d) {
                        let t = new iP(n, e, aH, a, r),
                            f = (await t.call("getAllExtensions")).map(e => e.metadata.implementation);
                        i = await iO(f, n, r)
                    } else if (c) {
                        let t = new iP(n, e, aG, a, r),
                            f = (await t.call("getAllPlugins")).map(e => e.pluginAddress),
                            s = Array.from(new Set(f));
                        i = await iO(s, n, r)
                    } else if (l) {
                        let t = new F.CH(e, ["function facets() external view returns (tuple(address,bytes4[])[])"], n),
                            a = (await t.facets()).map(e => e[0]);
                        i = await iO(a, n, r)
                    }
                } catch (e) {}
                return i.length > 0 ? n3([...i], t) : t
            }
            let i$ = {
                    admin: "",
                    transfer: "TRANSFER_ROLE",
                    minter: "MINTER_ROLE",
                    pauser: "PAUSER_ROLE",
                    lister: "LISTER_ROLE",
                    asset: "ASSET_ROLE",
                    unwrap: "UNWRAP_ROLE",
                    factory: "FACTORY_ROLE",
                    signer: "SIGNER_ROLE",
                    metadata: "METADATA_ROLE",
                    revoke: "REVOKE_ROLE",
                    migration: "MIGRATION_ROLE"
                },
                iI = Object.keys(i$);

            function iL(e) {
                return "admin" === e ? T.hexZeroPad([0], 32) : B.id(i$[e])
            }
            let iN = tB.merge(tO).merge(tN).merge(tL),
                iM = tR.merge(tO).merge(tN).merge(tL),
                i_ = {
                    deploy: iN.merge(t$).merge(tD).merge(tI),
                    output: iM,
                    input: iN
                },
                ij = tB.merge(tN).merge(tL),
                iU = tR.merge(tN).merge(tL),
                iW = {
                    deploy: ij.merge(t$).merge(tD).merge(tI),
                    output: iU,
                    input: ij
                },
                iG = tB.merge(tO).merge(tN).merge(tL),
                iH = tR.merge(tO).merge(tN).merge(tL),
                iV = {
                    deploy: iG.merge(t$).merge(tD).merge(tI),
                    output: iH,
                    input: iG
                },
                iK = {
                    deploy: tB.merge(t$).merge(tI),
                    output: tR,
                    input: tB
                },
                iZ = tB.merge(tO).merge(tL),
                iJ = tR.merge(tO).merge(tL),
                iq = {
                    deploy: iZ.merge(tI),
                    output: iJ,
                    input: iZ
                },
                iY = tB.merge(tO).merge(tL),
                iX = tR.merge(tO).merge(tL),
                iQ = {
                    deploy: iY.merge(t$).merge(tI),
                    output: iX,
                    input: iY
                },
                i0 = N.z.object({
                    address: tl,
                    sharesBps: tw.gt(0, "Shares must be greater than 0")
                }),
                i1 = i0.extend({
                    address: tl,
                    sharesBps: tw
                }),
                i6 = tB.extend({
                    recipients: N.z.array(i0).default([]).superRefine((e, t) => {
                        let n = {},
                            a = 0;
                        for (let r = 0; r < e.length; r++) {
                            let i = e[r];
                            n[i.address] && t.addIssue({
                                code: N.z.ZodIssueCode.custom,
                                message: "Duplicate address.",
                                path: [r, "address"]
                            }), n[i.address] = !0, (a += i.sharesBps) > 1e4 && t.addIssue({
                                code: N.z.ZodIssueCode.custom,
                                message: "Total shares cannot go over 100%.",
                                path: [r, "sharesBps"]
                            })
                        }
                        1e4 !== a && t.addIssue({
                            code: N.z.ZodIssueCode.custom,
                            message: `Total shares need to add up to 100%. Total shares are currently ${a/100}%`,
                            path: []
                        })
                    })
                }),
                i5 = tR.extend({
                    recipients: N.z.array(i1)
                }),
                i2 = {
                    deploy: i6.merge(i6).merge(tI),
                    output: i5,
                    input: i6
                },
                i8 = tB.merge(tO).merge(tL),
                i3 = tR.merge(tO).merge(tL),
                i4 = {
                    deploy: i8.merge(t$).merge(tD).merge(tI),
                    output: i3,
                    input: i8
                },
                i9 = tB.merge(tL),
                i7 = tR.merge(tL),
                fe = {
                    deploy: i9.merge(t$).merge(tD).merge(tI),
                    output: i7,
                    input: i9
                },
                ft = tB.merge(tO).merge(tL),
                fn = tR.merge(tO).merge(tL),
                fa = {
                    deploy: ft.merge(t$).merge(tD).merge(tI),
                    output: fn,
                    input: ft
                },
                fr = N.z.object({
                    voting_delay_in_blocks: N.z.number().min(0).default(0),
                    voting_period_in_blocks: N.z.number().min(1).default(1),
                    voting_token_address: tl,
                    voting_quorum_fraction: tE.default(0),
                    proposal_token_threshold: tS.default(1)
                }),
                fi = fr.extend({
                    proposal_token_threshold: tT
                }),
                ff = tB.merge(fr),
                fs = tR.merge(fi),
                fo = {
                    deploy: ff.merge(tI),
                    output: fs,
                    input: ff
                },
                fc = ["admin"],
                fd = ["admin", "minter", "transfer", "metadata"],
                fl = ["admin", "lister", "asset"],
                fu = ["admin", "minter", "asset", "transfer"],
                fm = ["admin", "transfer"],
                fp = ["admin", "transfer", "minter", "unwrap", "asset"],
                fb = {
                    vote: "vote",
                    token: "token",
                    "edition-drop": "edition-drop",
                    edition: "edition",
                    marketplace: "marketplace",
                    "marketplace-v3": "marketplace-v3",
                    multiwrap: "multiwrap",
                    "nft-collection": "nft-collection",
                    "nft-drop": "nft-drop",
                    pack: "pack",
                    "signature-drop": "signature-drop",
                    split: "split",
                    "token-drop": "token-drop"
                },
                fg = {
                    name: "DropERC1155",
                    contractType: fb["edition-drop"],
                    schema: i_,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fg.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(4149), n.e(7009), n.e(4875)]).then(n.bind(n, 94875)), o.getNetwork()]);
                        return new d.EditionDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rg(e, t, a);
                        if (r) return r;
                        let i = await fS(e, t);
                        return !i || i.version > 2 ? (await n.e(794).then(n.t.bind(n, 30794, 19))).default : (await n.e(2919).then(n.t.bind(n, 12919, 19))).default
                    }
                },
                fh = {
                    name: "TokenERC1155",
                    contractType: fb.edition,
                    schema: i4,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fh.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(4149), n.e(7009), n.e(6022)]).then(n.bind(n, 36022)), o.getNetwork()]);
                        return new d.Edition(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(8469).then(n.t.bind(n, 38469, 19))).default
                },
                fy = {
                    name: "Marketplace",
                    contractType: fb.marketplace,
                    schema: iK,
                    roles: fl,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fy.getAbi(i, o, f), Promise.all([n.e(1814), n.e(7255)]).then(n.bind(n, 77255)), o.getNetwork()]);
                        return new d.Marketplace(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(8838).then(n.t.bind(n, 38838, 19))).default
                },
                fw = {
                    name: "MarketplaceV3",
                    contractType: fb["marketplace-v3"],
                    schema: iK,
                    roles: fl,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fw.getAbi(i, o, f, s), Promise.all([n.e(1814), n.e(7659), n.e(6840)]).then(n.bind(n, 38643)), o.getNetwork()]);
                        return new d.MarketplaceV3(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a, r) => {
                        let i = (await t.getNetwork()).chainId;
                        if (280 === i || 324 === i) {
                            let e = (await nu(nl, "MarketplaceV3", "latest", a, r ? .clientId, r ? .secretKey)).metadataUri;
                            return await rh(e, a)
                        }
                        let f = await rg(e, t, a);
                        if (f) return await iD(e, f, t, {}, a);
                        let s = (await n.e(6079).then(n.t.bind(n, 86079, 19))).default;
                        return await iD(e, tJ.parse(s || []), t, {}, a)
                    }
                },
                fE = {
                    name: "Multiwrap",
                    contractType: fb.multiwrap,
                    schema: iq,
                    roles: fp,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fE.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4149), n.e(1345), n.e(1460)]).then(n.bind(n, 71460)), o.getNetwork()]);
                        return new d.Multiwrap(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(8133).then(n.t.bind(n, 18133, 19))).default
                },
                fk = {
                    name: "TokenERC721",
                    contractType: fb["nft-collection"],
                    schema: fa,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fk.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4149), n.e(1345), n.e(8485)]).then(n.bind(n, 48485)), o.getNetwork()]);
                        return new d.NFTCollection(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(7505).then(n.t.bind(n, 27505, 19))).default
                },
                fA = {
                    name: "DropERC721",
                    contractType: fb["nft-drop"],
                    schema: iV,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fA.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4149), n.e(1345), n.e(4409)]).then(n.bind(n, 24409)), o.getNetwork()]);
                        return new d.NFTDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rg(e, t, a);
                        if (r) return r;
                        let i = await fS(e, t);
                        return !i || i.version > 3 ? (await n.e(4380).then(n.t.bind(n, 14380, 19))).default : (await n.e(4867).then(n.t.bind(n, 54867, 19))).default
                    }
                },
                fC = {
                    name: "Pack",
                    contractType: fb.pack,
                    schema: iQ,
                    roles: fu,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fC.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4149), n.e(7009), n.e(4905), n.e(2586)]).then(n.bind(n, 12586)), o.getNetwork()]);
                        return new d.Pack(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || tJ.parse((await n.e(6482).then(n.t.bind(n, 16482, 19))).default || [])
                },
                fv = {
                    name: "SignatureDrop",
                    contractType: fb["signature-drop"],
                    schema: iV,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fv.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4149), n.e(1345), n.e(974)]).then(n.bind(n, 40974)), o.getNetwork()]);
                        return new d.SignatureDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rg(e, t, a);
                        if (r) return r;
                        let i = await fS(e, t);
                        return !i || i.version > 4 ? (await n.e(2184).then(n.t.bind(n, 42184, 19))).default : (await n.e(2717).then(n.t.bind(n, 32717, 19))).default
                    }
                },
                fz = {
                    name: "Split",
                    contractType: fb.split,
                    schema: i2,
                    roles: fc,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fz.getAbi(i, o, f), Promise.all([n.e(1814), n.e(5533)]).then(n.bind(n, 35533)), o.getNetwork()]);
                        return new d.Split(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(4338).then(n.t.bind(n, 54338, 19))).default
                },
                fF = {
                    name: "DropERC20",
                    contractType: fb["token-drop"],
                    schema: iW,
                    roles: fm,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fF.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4905), n.e(1114)]).then(n.bind(n, 21114)), o.getNetwork()]);
                        return new d.TokenDrop(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => {
                        let r = await rg(e, t, a);
                        if (r) return r;
                        let i = await fS(e, t);
                        return !i || i.version > 2 ? (await n.e(4279).then(n.t.bind(n, 4279, 19))).default : (await n.e(562).then(n.t.bind(n, 70562, 19))).default
                    }
                },
                fx = {
                    name: "TokenERC20",
                    contractType: fb.token,
                    schema: fe,
                    roles: fd,
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fx.getAbi(i, o, f), Promise.all([n.e(1814), n.e(9690), n.e(6204), n.e(4905), n.e(7714)]).then(n.bind(n, 87714)), o.getNetwork()]);
                        return new d.Token(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(2687).then(n.t.bind(n, 22687, 19))).default
                },
                fT = {
                    name: "VoteERC20",
                    contractType: fb.vote,
                    schema: fo,
                    roles: [],
                    initialize: async function() {
                        for (var e = arguments.length, t = Array(e), a = 0; a < e; a++) t[a] = arguments[a];
                        let [r, i, f, s] = t, [, o] = tf(r, s), [c, d, l] = await Promise.all([fT.getAbi(i, o, f), n.e(7899).then(n.bind(n, 57899)), o.getNetwork()]);
                        return new d.Vote(r, i, f, s, c, l.chainId)
                    },
                    getAbi: async (e, t, a) => await rg(e, t, a) || (await n.e(5311).then(n.t.bind(n, 75311, 19))).default
                };
            async function fS(e, t) {
                try {
                    return await nm(e, t)
                } catch (e) {
                    return
                }
            }
            let fP = {
                    [fb["edition-drop"]]: fg,
                    [fb.edition]: fh,
                    [fb.marketplace]: fy,
                    [fb["marketplace-v3"]]: fw,
                    [fb.multiwrap]: fE,
                    [fb["nft-collection"]]: fk,
                    [fb["nft-drop"]]: fA,
                    [fb.pack]: fC,
                    [fb["signature-drop"]]: fv,
                    [fb.split]: fz,
                    [fb["token-drop"]]: fF,
                    [fb.token]: fx,
                    [fb.vote]: fT
                },
                fB = {
                    [fb["edition-drop"]]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
                    [fb.edition]: "",
                    [fb.marketplace]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
                    [fb["marketplace-v3"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
                    [fb.multiwrap]: "",
                    [fb["nft-collection"]]: "",
                    [fb["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
                    [fb.pack]: "",
                    [fb["signature-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
                    [fb.split]: "",
                    [fb["token-drop"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
                    [fb.token]: "",
                    [fb.vote]: ""
                },
                fR = {
                    name: "SmartContract",
                    contractType: "custom",
                    schema: {},
                    roles: iI
                },
                fO = { ...fP,
                    [fR.contractType]: fR
                };

            function fD(e) {
                return Object.values(fO).find(t => t.name === e) ? .contractType || "custom"
            }

            function f$(e) {
                return Object.values(fO).find(t => t.contractType === e) ? .name
            }
        }
    }
]);